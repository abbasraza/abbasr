---
layout: post
title: How a toolchain is constructed
date: '2019-12-24T17:34:00.002+05:00'
author: Abbas Raza
tags: 
modified_time: '2019-12-24T17:34:49.070+05:00'
blogger_id: tag:blogger.com,1999:blog-3367966882409306161.post-786619070991279266
blogger_orig_url: https://abbas-raza.blogspot.com/2019/12/how-toolchain-is-constructed.html
---

<div dir="ltr" style="text-align: left;" trbidi="on"><header class="post-header" style="background-color: #fdfdfd; color: #111111; font-family: Helvetica, Arial, sans-serif; font-size: 16px; margin-bottom: 30px;"><h1 class="post-title" style="font-size: 42px; font-weight: 300; letter-spacing: -1px; line-height: 1; margin: 20px 0px 0px; padding: 0px;">How a toolchain is constructed</h1></header><article class="post-content" style="background-color: #fdfdfd; color: #111111; font-family: Helvetica, Arial, sans-serif; font-size: 16px; margin-bottom: 30px;"><div style="margin-bottom: 15px; padding: 0px;">This is the result of a&nbsp;<a href="http://sourceware.org/ml/crossgcc/2011-01/msg00060.html" style="color: #1756a9; text-decoration-line: none;">discussion with Francesco Turco</a>.</div><div style="margin-bottom: 15px; padding: 0px;">Francesco had a&nbsp;<a href="http://fturco.org/wiki/doku.php?id=debian:cross-compiler" style="color: #1756a9; text-decoration-line: none;">nice tutorial for beginners</a>&nbsp;[dead link, Wayback Machine has no archived version], along with a sample, step-by-step procedure to build a toolchain for an ARM target from an x86_64 Debian host.</div><div style="margin-bottom: 15px; padding: 0px;">Thank you Francesco for initiating this!</div><h2 id="i-want-a-cross-compiler-what-is-this-toolchain-youre-speaking-about" style="font-size: 32px; font-weight: 300; margin: 0px 0px 15px; padding: 0px;">I want a cross-compiler! What is this toolchain you’re speaking about?</h2><div style="margin-bottom: 15px; padding: 0px;">A cross-compiler is in fact a collection of different tools set up to tightly work together. The tools are arranged in a way that they are chained, in a kind of cascade, where the output from one becomes the input to another one, to ultimately produce the actual binary code that runs on a machine. So, we call this arrangement a “toolchain”. When a toolchain is meant to generate code for a machine different from the machine it runs on, this is called a cross-toolchain.</div><h2 id="so-what-are-those-components-in-a-toolchain" style="font-size: 32px; font-weight: 300; margin: 0px 0px 15px; padding: 0px;">So, what are those components in a toolchain?</h2><div style="margin-bottom: 15px; padding: 0px;">The components that play a role in the toolchain are first and foremost the compiler itself. The compiler turns source code (in C, C++, whatever) into assembly code. The compiler of choice is the GNU compiler collection, well known as&nbsp;<code class="highlighter-rouge" style="background-color: #eeeeff; border-radius: 3px; border: 1px solid rgb(232, 232, 232); font-size: 15px; padding: 1px 5px;">gcc</code>.</div><div style="margin-bottom: 15px; padding: 0px;">The assembly code is interpreted by the assembler to generate object code. This is done by the binary utilities, such as the GNU&nbsp;<em>binutils</em>.</div><div style="margin-bottom: 15px; padding: 0px;">Once the different object code files have been generated, they got to get aggregated together to form the final executable binary. This is called linking, and is achieved with the use of a linker. The GNU&nbsp;<em>binutils</em>&nbsp;also come with a linker.</div><div style="margin-bottom: 15px; padding: 0px;">So far, we get a complete toolchain that is capable of turning source code into actual executable code. Depending on the Operating System, or the lack thereof, running on the target, we also need the C library. The C library provides a standard abstraction layer that performs basic tasks (such as allocating memory, printing output on a terminal, managing file access…). There are many C libraries, each targeted to different systems. For the Linux&nbsp;<em>desktop</em>, there is&nbsp;<code class="highlighter-rouge" style="background-color: #eeeeff; border-radius: 3px; border: 1px solid rgb(232, 232, 232); font-size: 15px; padding: 1px 5px;">glibc</code>&nbsp;or&nbsp;<code class="highlighter-rouge" style="background-color: #eeeeff; border-radius: 3px; border: 1px solid rgb(232, 232, 232); font-size: 15px; padding: 1px 5px;">eglibc</code>&nbsp;or even&nbsp;<code class="highlighter-rouge" style="background-color: #eeeeff; border-radius: 3px; border: 1px solid rgb(232, 232, 232); font-size: 15px; padding: 1px 5px;">uClibc</code>, for embedded Linux, you have a choice of&nbsp;<code class="highlighter-rouge" style="background-color: #eeeeff; border-radius: 3px; border: 1px solid rgb(232, 232, 232); font-size: 15px; padding: 1px 5px;">eglibc</code>&nbsp;or&nbsp;<code class="highlighter-rouge" style="background-color: #eeeeff; border-radius: 3px; border: 1px solid rgb(232, 232, 232); font-size: 15px; padding: 1px 5px;">uClibc</code>, while for system without an operating system, you may use&nbsp;<code class="highlighter-rouge" style="background-color: #eeeeff; border-radius: 3px; border: 1px solid rgb(232, 232, 232); font-size: 15px; padding: 1px 5px;">newlib</code>,&nbsp;<code class="highlighter-rouge" style="background-color: #eeeeff; border-radius: 3px; border: 1px solid rgb(232, 232, 232); font-size: 15px; padding: 1px 5px;">dietlibc</code>, or even none at all. There a few other C libraries, but they are not as widely used, and/or are targeted to very specific needs (e.g.,&nbsp;<code class="highlighter-rouge" style="background-color: #eeeeff; border-radius: 3px; border: 1px solid rgb(232, 232, 232); font-size: 15px; padding: 1px 5px;">klibc</code>&nbsp;is a very small subset of the C library aimed at building constrained initial ramdisks).</div><div style="margin-bottom: 15px; padding: 0px;">Under Linux, the C library needs to know the API to the kernel to decide what features are present, and if needed, what emulation to include for missing features. That API is provided by the kernel headers. Note: this is Linux-specific (and potentially a very few others), the C library on other OSes do not need the kernel headers.</div><h2 id="and-now-how-do-all-these-components-chained-together" style="font-size: 32px; font-weight: 300; margin: 0px 0px 15px; padding: 0px;">And now, how do all these components chained together?</h2><div style="margin-bottom: 15px; padding: 0px;">So far, all major components have been covered, but yet there is a specific order they need to be built. Here we see what the dependencies are, starting with the compiler we want to ultimately use. We call that compiler the&nbsp;<em>final compiler</em>.</div><ul style="margin: 0px 0px 15px 30px; padding: 0px;"><li style="padding-left: 10px;"><div style="margin-bottom: 15px; padding: 0px;">the final compiler needs the C library, to know how to use it, but:</div></li><li style="padding-left: 10px;"><div style="margin-bottom: 15px; padding: 0px;">building the C library requires a compiler</div></li></ul><div style="margin-bottom: 15px; padding: 0px;">A needs B which needs A. This is the classic chicken’n’egg problem… This is solved by building a stripped-down compiler that does not need the C library, but is capable of building it. We call it a bootstrap, initial, or core compiler. So here is the new dependency list:</div><ul style="margin: 0px 0px 15px 30px; padding: 0px;"><li style="padding-left: 10px;"><div style="margin-bottom: 15px; padding: 0px;">the final compiler needs the C library, to know how to use it,</div></li><li style="padding-left: 10px;"><div style="margin-bottom: 15px; padding: 0px;">building the C library requires a core compiler but:</div></li><li style="padding-left: 10px;"><div style="margin-bottom: 15px; padding: 0px;">the core compiler needs the C library headers and start files, to know how to use the C library</div></li></ul><div style="margin-bottom: 15px; padding: 0px;">B needs C which needs B. Chicken’n’egg, again. To solve this one, we will need to build a C library that will only install its headers and start files. The start files (also called “C runtime”, or CRT) are a very few files that gcc needs to be able to turn on thread local storage (TLS) on an NPTL system. So now we have:</div><ul style="margin: 0px 0px 15px 30px; padding: 0px;"><li style="padding-left: 10px;"><div style="margin-bottom: 15px; padding: 0px;">the final compiler needs the C library, to know how to use it,</div></li><li style="padding-left: 10px;"><div style="margin-bottom: 15px; padding: 0px;">building the C library requires a core compiler</div></li><li style="padding-left: 10px;"><div style="margin-bottom: 15px; padding: 0px;">the core compiler needs the C library headers and start files, to know how to use the C library but:</div></li><li style="padding-left: 10px;"><div style="margin-bottom: 15px; padding: 0px;">building the start files require a compiler</div></li></ul><div style="margin-bottom: 15px; padding: 0px;">Geez… C needs D which needs C, yet again. So we need to build a yet simpler compiler, that does not need the headers and does need the start files. This compiler is also a bootstrap, initial or core compiler. In order to differentiate the two core compilers, let’s call that one&nbsp;<code class="highlighter-rouge" style="background-color: #eeeeff; border-radius: 3px; border: 1px solid rgb(232, 232, 232); font-size: 15px; padding: 1px 5px;">core pass 1</code>, and the former one&nbsp;<code class="highlighter-rouge" style="background-color: #eeeeff; border-radius: 3px; border: 1px solid rgb(232, 232, 232); font-size: 15px; padding: 1px 5px;">core pass 2</code>. The dependency list becomes:</div><ul style="margin: 0px 0px 15px 30px; padding: 0px;"><li style="padding-left: 10px;"><div style="margin-bottom: 15px; padding: 0px;">the final compiler needs the C library, to know how to use it,</div></li><li style="padding-left: 10px;"><div style="margin-bottom: 15px; padding: 0px;">building the C library requires a compiler</div></li><li style="padding-left: 10px;"><div style="margin-bottom: 15px; padding: 0px;">the core pass 2 compiler needs the C library headers and start files, to know how to use the C library</div></li><li style="padding-left: 10px;"><div style="margin-bottom: 15px; padding: 0px;">building the start files requires a compiler</div></li><li style="padding-left: 10px;"><div style="margin-bottom: 15px; padding: 0px;">we need a core pass 1 compiler</div></li></ul><div style="margin-bottom: 15px; padding: 0px;">And as we said earlier, the C library also requires the kernel headers. There is no requirement for the kernel headers, so end of story in this case:</div><ul style="margin: 0px 0px 15px 30px; padding: 0px;"><li style="padding-left: 10px;"><div style="margin-bottom: 15px; padding: 0px;">the final compiler needs the C library, to know how to use it,</div></li><li style="padding-left: 10px;"><div style="margin-bottom: 15px; padding: 0px;">building the C library requires a core compiler</div></li><li style="padding-left: 10px;"><div style="margin-bottom: 15px; padding: 0px;">the core pass 2 compiler needs the C library headers and start files, to know how to use the C library</div></li><li style="padding-left: 10px;"><div style="margin-bottom: 15px; padding: 0px;">building the start files requires a compiler and the kernel headers</div></li><li style="padding-left: 10px;"><div style="margin-bottom: 15px; padding: 0px;">we need a core pass 1 compiler</div></li></ul><div style="margin-bottom: 15px; padding: 0px;">We need to add a few new requirements. The moment we compile code for the target, we need the assembler and the linker. Such code is, of course, built from the C library, so we need to build the binutils before the C library start files, and the complete C library itself. Also, some code in gcc will turn to run on the target as well. Luckily, there is no requirement for the binutils. So, our dependency chain is as follows:</div><ul style="margin: 0px 0px 15px 30px; padding: 0px;"><li style="padding-left: 10px;"><div style="margin-bottom: 15px; padding: 0px;">the final compiler needs the C library, to know how to use it, and the binutils</div></li><li style="padding-left: 10px;"><div style="margin-bottom: 15px; padding: 0px;">building the C library requires a core pass 2 compiler and the binutils</div></li><li style="padding-left: 10px;"><div style="margin-bottom: 15px; padding: 0px;">the core pass 2 compiler needs the C library headers and start files, to know how to use the C library, and the binutils</div></li><li style="padding-left: 10px;"><div style="margin-bottom: 15px; padding: 0px;">building the start files requires a compiler, the kernel headers and the binutils</div></li><li style="padding-left: 10px;"><div style="margin-bottom: 15px; padding: 0px;">the core pass 1 compiler needs the binutils</div></li></ul><div style="margin-bottom: 15px; padding: 0px;">Which turns in this order to build the components:</div><ol style="margin: 0px 0px 15px 30px; padding: 0px;"><li style="padding-left: 10px;"><div style="margin-bottom: 15px; padding: 0px;">binutils</div></li><li style="padding-left: 10px;"><div style="margin-bottom: 15px; padding: 0px;">core pass 1 compiler</div></li><li style="padding-left: 10px;"><div style="margin-bottom: 15px; padding: 0px;">kernel headers</div></li><li style="padding-left: 10px;"><div style="margin-bottom: 15px; padding: 0px;">C library headers and start files</div></li><li style="padding-left: 10px;"><div style="margin-bottom: 15px; padding: 0px;">core pass 2 compiler</div></li><li style="padding-left: 10px;"><div style="margin-bottom: 15px; padding: 0px;">complete C library</div></li><li style="padding-left: 10px;"><div style="margin-bottom: 15px; padding: 0px;">final compiler</div></li></ol><div style="margin-bottom: 15px; padding: 0px;">Yes! :-) But are we done yet?</div><div style="margin-bottom: 15px; padding: 0px;">In fact, no, there are still missing dependencies. As far as the tools themselves are involved, we do not need anything else.</div><div style="margin-bottom: 15px; padding: 0px;">But gcc has a few pre-requisites. It relies on a few external libraries to perform some non-trivial tasks (such as handling complex numbers in constants…). There are a few options to build those libraries. First, one may think to rely on a Linux distribution to provide those libraries. Alas, they were not widely available until very, very recently. So, if the distro is not too recent, chances are that we will have to build those libraries (which we do below). The affected libraries are:</div><ul style="margin: 0px 0px 15px 30px; padding: 0px;"><li style="padding-left: 10px;"><div style="margin-bottom: 15px; padding: 0px;">the GNU Multiple Precision Arithmetic Library, GMP;</div></li><li style="padding-left: 10px;"><div style="margin-bottom: 15px; padding: 0px;">the C library for multiple-precision floating-point computations with correct rounding, MPFR;</div></li><li style="padding-left: 10px;"><div style="margin-bottom: 15px; padding: 0px;">the C library for the arithmetic of complex numbers, MPC.</div></li></ul><div style="margin-bottom: 15px; padding: 0px;">The dependencies for those libraries are:</div><ul style="margin: 0px 0px 15px 30px; padding: 0px;"><li style="padding-left: 10px;"><div style="margin-bottom: 15px; padding: 0px;">MPC requires GMP and MPFR</div></li><li style="padding-left: 10px;"><div style="margin-bottom: 15px; padding: 0px;">MPFR requires GMP</div></li><li style="padding-left: 10px;"><div style="margin-bottom: 15px; padding: 0px;">GMP has no pre-requisite</div></li></ul><div style="margin-bottom: 15px; padding: 0px;">So, the build order becomes:</div><ol style="margin: 0px 0px 15px 30px; padding: 0px;"><li style="padding-left: 10px;"><div style="margin-bottom: 15px; padding: 0px;">GMP</div></li><li style="padding-left: 10px;"><div style="margin-bottom: 15px; padding: 0px;">MPFR</div></li><li style="padding-left: 10px;"><div style="margin-bottom: 15px; padding: 0px;">MPC</div></li><li style="padding-left: 10px;"><div style="margin-bottom: 15px; padding: 0px;">binutils</div></li><li style="padding-left: 10px;"><div style="margin-bottom: 15px; padding: 0px;">core pass 1 compiler</div></li><li style="padding-left: 10px;"><div style="margin-bottom: 15px; padding: 0px;">kernel headers</div></li><li style="padding-left: 10px;"><div style="margin-bottom: 15px; padding: 0px;">C library headers and start files</div></li><li style="padding-left: 10px;"><div style="margin-bottom: 15px; padding: 0px;">core pass 2 compiler</div></li><li style="padding-left: 10px;"><div style="margin-bottom: 15px; padding: 0px;">complete C library</div></li><li style="padding-left: 10px;"><div style="margin-bottom: 15px; padding: 0px;">final compiler</div></li></ol><div style="margin-bottom: 15px; padding: 0px;">Yes! Or yet some more?</div><div style="margin-bottom: 15px; padding: 0px;">This is now sufficient to build a functional toolchain. So if you’ve had enough for now, you can stop here. Or if you are curious, you can continue reading.</div><div style="margin-bottom: 15px; padding: 0px;">gcc can also make use of a few other external libraries. These additional, optional libraries are used to enable advanced features in gcc, such as loop optimisation (GRAPHITE) and Link Time Optimisation (LTO). If you want to use these, you’ll need three additional libraries:</div><div style="margin-bottom: 15px; padding: 0px;">To enable GRAPHITE, depending on GCC version, it may need one or more of the following:</div><ul style="margin: 0px 0px 15px 30px; padding: 0px;"><li style="padding-left: 10px;">the Parma Polyhedra Library, PPL;</li><li style="padding-left: 10px;">the Integer Set Library, ISL;</li><li style="padding-left: 10px;">the Chunky Loop Generator, using the PPL backend, CLooG/PPL;</li><li style="padding-left: 10px;">the Chunky Loop Generator, using the ISL backend, CLooG.</li></ul><div style="margin-bottom: 15px; padding: 0px;">To enable LTO: - the ELF object file access library, libelf</div><div style="margin-bottom: 15px; padding: 0px;">The dependencies for those libraries are:</div><ul style="margin: 0px 0px 15px 30px; padding: 0px;"><li style="padding-left: 10px;"><div style="margin-bottom: 15px; padding: 0px;">PPL requires GMP;</div></li><li style="padding-left: 10px;"><div style="margin-bottom: 15px; padding: 0px;">CLooG/PPL requires GMP and one of PPL or ISL;</div></li><li style="padding-left: 10px;"><div style="margin-bottom: 15px; padding: 0px;">ISL has no prerequisites;</div></li><li style="padding-left: 10px;"><div style="margin-bottom: 15px; padding: 0px;">libelf has no pre-requisites.</div></li></ul><div style="margin-bottom: 15px; padding: 0px;">The list now looks like:</div><ol style="margin: 0px 0px 15px 30px; padding: 0px;"><li style="padding-left: 10px;"><div style="margin-bottom: 15px; padding: 0px;">GMP</div></li><li style="padding-left: 10px;"><div style="margin-bottom: 15px; padding: 0px;">MPFR</div></li><li style="padding-left: 10px;"><div style="margin-bottom: 15px; padding: 0px;">MPC</div></li><li style="padding-left: 10px;"><div style="margin-bottom: 15px; padding: 0px;">PPL (if needed)</div></li><li style="padding-left: 10px;"><div style="margin-bottom: 15px; padding: 0px;">ISL (if needed)</div></li><li style="padding-left: 10px;"><div style="margin-bottom: 15px; padding: 0px;">CLooG (if needed)</div></li><li style="padding-left: 10px;"><div style="margin-bottom: 15px; padding: 0px;">libelf (if needed)</div></li><li style="padding-left: 10px;"><div style="margin-bottom: 15px; padding: 0px;">binutils</div></li><li style="padding-left: 10px;"><div style="margin-bottom: 15px; padding: 0px;">core pass 1 compiler</div></li><li style="padding-left: 10px;"><div style="margin-bottom: 15px; padding: 0px;">kernel headers</div></li><li style="padding-left: 10px;"><div style="margin-bottom: 15px; padding: 0px;">C library headers and start files</div></li><li style="padding-left: 10px;"><div style="margin-bottom: 15px; padding: 0px;">core pass 2 compiler</div></li><li style="padding-left: 10px;"><div style="margin-bottom: 15px; padding: 0px;">complete C library</div></li><li style="padding-left: 10px;"><div style="margin-bottom: 15px; padding: 0px;">final compiler</div></li></ol><div style="margin-bottom: 15px; padding: 0px;">This list is now complete! Wouhou! Or is it?</div><h2 id="but-why-does-crosstool-ng-have-more-steps" style="font-size: 32px; font-weight: 300; margin: 0px 0px 15px; padding: 0px;">But why does crosstool-NG have more steps?</h2><div style="margin-bottom: 15px; padding: 0px;">The already thirteen steps are the necessary steps, from a theoretical point of view. In reality, though, there are small differences; there are three different reasons for the additional steps in crosstool-NG.</div><div style="margin-bottom: 15px; padding: 0px;">First, the GNU binutils do not support some kinds of output. It is not possible to generate&nbsp;<em>flat</em>&nbsp;binaries with binutils, so we have to use another component that adds this support:&nbsp;<code class="highlighter-rouge" style="background-color: #eeeeff; border-radius: 3px; border: 1px solid rgb(232, 232, 232); font-size: 15px; padding: 1px 5px;">elf2flt</code>.&nbsp;<code class="highlighter-rouge" style="background-color: #eeeeff; border-radius: 3px; border: 1px solid rgb(232, 232, 232); font-size: 15px; padding: 1px 5px;">elf2flt</code>&nbsp;also requires the&nbsp;<code class="highlighter-rouge" style="background-color: #eeeeff; border-radius: 3px; border: 1px solid rgb(232, 232, 232); font-size: 15px; padding: 1px 5px;">zlib</code>&nbsp;compression library - we may not be able to use the host’s zlib if we’re building a canadian or cross-native toolchain.</div><div style="margin-bottom: 15px; padding: 0px;">Second, localizations of the toolchain require additional libraries on some host OSes:&nbsp;<code class="highlighter-rouge" style="background-color: #eeeeff; border-radius: 3px; border: 1px solid rgb(232, 232, 232); font-size: 15px; padding: 1px 5px;">gettext</code>&nbsp;and&nbsp;<code class="highlighter-rouge" style="background-color: #eeeeff; border-radius: 3px; border: 1px solid rgb(232, 232, 232); font-size: 15px; padding: 1px 5px;">libiconv</code>.</div><div style="margin-bottom: 15px; padding: 0px;">Third, crosstool-NG can also build some additional debug utilities to run on the target. This is where we build, for example, the&nbsp;<code class="highlighter-rouge" style="background-color: #eeeeff; border-radius: 3px; border: 1px solid rgb(232, 232, 232); font-size: 15px; padding: 1px 5px;">cross-gdb</code>, the&nbsp;<code class="highlighter-rouge" style="background-color: #eeeeff; border-radius: 3px; border: 1px solid rgb(232, 232, 232); font-size: 15px; padding: 1px 5px;">gdbserver</code>&nbsp;and the native&nbsp;<code class="highlighter-rouge" style="background-color: #eeeeff; border-radius: 3px; border: 1px solid rgb(232, 232, 232); font-size: 15px; padding: 1px 5px;">gdb</code>&nbsp;(the last two run on the target, the first runs on the same machine as the toolchain). The others (<code class="highlighter-rouge" style="background-color: #eeeeff; border-radius: 3px; border: 1px solid rgb(232, 232, 232); font-size: 15px; padding: 1px 5px;">strace</code>,&nbsp;<code class="highlighter-rouge" style="background-color: #eeeeff; border-radius: 3px; border: 1px solid rgb(232, 232, 232); font-size: 15px; padding: 1px 5px;">ltrace</code>, DUMA and&nbsp;<code class="highlighter-rouge" style="background-color: #eeeeff; border-radius: 3px; border: 1px solid rgb(232, 232, 232); font-size: 15px; padding: 1px 5px;">dmalloc</code>) are absolutely not related to the toolchain, but are nice-to-have stuff that can greatly help when developing, so are included as goodies (and they are quite easy to build, so it’s OK; more complex stuff is not worth the effort to include in crosstool-NG).</div></article></div>