---
layout: post
title: kernel ring buffer
date: '2014-07-02T21:48:00.001+05:00'
author: Abbas Raza
tags: 
modified_time: '2014-07-02T21:48:37.352+05:00'
blogger_id: tag:blogger.com,1999:blog-3367966882409306161.post-9218869501353972228
blogger_orig_url: https://abbas-raza.blogspot.com/2014/07/kernel-ring-buffer.html
---

<div dir="ltr" style="text-align: left;" trbidi="on"><span style="font-weight: bold;"><span style="font-size: 130%;">Kernel Log (Ring) Buffer<br /><span style="font-size: 100%;"><br /></span></span></span><span style="font-size: 100%;">Linux  kernel generates log messages using printk(). These messages are stored  in a "ring buffer". The size of this buffer is controlled by a kernel  configuration parameter:</span><br /><br /><blockquote>CONFIG_LOG_BUF_SHIFT</blockquote>The  default value of this parameter is 14, which means 2^14 bytes, thus  16KB. The size of the buffer can not be changed online so it should be  modified (if you'd like to have a larger or smaller buffer) before  compiling the kernel (<a href="http://www.blogger.com/post-edit.g?blogID=9221273284073253620&amp;postID=7430538840468663616">more information on kernel compilation</a>). <span style="font-size: 78%;">(1)</span><br /><br /><span style="font-weight: bold;"><span style="font-size: 130%;">printk() - print() function at the Kernel level</span></span><span style="font-size: 100%;">printk()  is used to print messages at the kernel level. The size of the message  can not be larger than 1KB.</span><br />The syntax of printk is  <br /><div class="post-body entry-content" id="post-body-2377539433348056102" itemprop="description articleBody"><div dir="ltr"><br /><textarea cols="70" rows="2">printk ("log level" "message", <arguments>);  </textarea><br /><br /> The log levels decide the importance of the message being printed, kernel defines 8 log levels in the file printk.h  <br /><br /><textarea cols="70" rows="10">#define KERN_EMERG "<0>" /* system is unusable*/ #define KERN_ALERT "<1>" /* action must be taken immediately*/ #define KERN_CRIT "<2>" /* critical conditions*/ #define KERN_ERR "<3>" /* error conditions*/ #define KERN_WARNING "<4>" /* warning conditions*/ #define KERN_NOTICE "<5>" /* normal but significant condition*/ #define KERN_INFO "<6>" /* informational*/ #define KERN_DEBUG "<7>" /* debug-level messages*/ </textarea><br /><br />We can see each log level corresponds to a number and the lower the number higher the importance of the message.  The levels are useful in deciding what should be displayed to the user on the console and what should not be.  <br /><br /> Every console has log level called as the the console log level and any  message with a log level number lesser than the console log level gets  displayed on the console, and other messages which have a log level  number higher or equal to the console log level are logged in the kernel  log which can be looked into using the command "dmesg".  <br /><br />  The console loglevel can be found by looking into the file /proc/sys/kernel/printk  <br /><br /><textarea cols="70" rows="2">$ cat /proc/sys/kernel/printk 4 4 1 7 </textarea><br /><br /> The first number in the output is the console log level, the second is  the default log level, third is the minimum log level and fourth is the  maximum log level.  <br /><br /> Log level 4 corresponds to KERN_WARNING. Thus all the messages with log  levels 3,2,1 and 0 will get displayed on the screen as well as logged  and the messages with log level 4,5,6,7 only get logged and can be  viewed using "dmesg".  <br /><br /> The console log level can be changed by writing into the proc entry  <br /><br /><textarea cols="70" rows="4">$ echo "6" > /proc/sys/kernel/printk $ cat /proc/sys/kernel/printk 6 4 1 7 </textarea><br /><br /> Now the console log level is set to 6, which is KERN_INFO. <br /></div></div><br /><span style="font-weight: bold;"></span><span style="font-size: 100%;"><br /></span><span style="font-weight: bold;"><span style="font-size: 130%;">How are Kernel Log Messages Exposed to User Space?</span></span><span style="font-size: 100%;">The  log buffer is exposed to user through /proc/kmsg file. If the file is  read one can catch the kernel log messages. In fact, there are available  programs to display the ingredients of the file /proc/kmsg, and log the  content of this file in a static file (e.g., klogd and syslogd deamons,  and syslog-ng logging facility). /proc is a memory filesystem (</span>it contains virtual files which reveals the current state of the running Linux kernel<span style="font-size: 100%;">),  and the content of /proc/kmsg are being overwritten. In addition,  reading from /proc/kmsg is destructive; that's, once you read a  line/message it's removed from the file.<span style="font-size: 78%;">(2)</span><br /><br />&nbsp;</span><br />What you are looking for is <code>/proc/kmsg</code>. This is the kernel ring buffer!<br />  <ol><li>Yes, this is inside kernel space. Any process trying to read it should have super user privileges to read it!</li><li>How to read it the ring buffer? Here is a beautiful illustration from IBM Developerworks</li></ol><img alt="Reading the Kernel Ring Buffer" src="http://i.stack.imgur.com/Ra9J4.gif" /><br />  <code>dmesg</code> would be your first resort! How does <a href="http://linux.die.net/man/8/dmesg">dmesg</a> accomplish its task? By a call to <code>syslog()</code>! How does <a href="http://linux.die.net/man/2/syslog">syslog</a> do its job? Through the system call interface which in turn call <code>do_syslog()</code>. <code>do_syslog()</code> does the finishing act like <a href="http://lxr.free-electrons.com/source/kernel/printk.c#L332">this.</a><br /><br /><b>dmesg:</b><br /><br /><b>Get the dmesg source from: </b><br /><b><cite>https://www.kernel.org/pub/<b>linux</b>/<b>util</b>s/<b>util</b>-<b>linux</b>/v<b>2.20</b>/</cite><a class="pplsrsla" data-ci="srslc_7" data-desc="Parent Directory - sha256sums.asc 25-Jan-2013 16:19 2.5K util-linux-2.20-rc1.tar .bz2 19-Jan-2012 12:00 4.3M util-linux-2.20-rc1.tar.gz 19-Jan-2012 12:00 5.8M ..." data-slg="webres" data-sli="srsl_7" data-title="Index of /pub/linux/utils/util-linux/v2.20" data-url="https://www.kernel.org/pub/linux/utils/util-linux/v2.20/" data-ved="0CG4Q5hkwBw" data-vli="srslcl_7" href="http://www.blogger.com/blogger.g?blogID=4188745509743673648" id="srsl_7" role="button" tabindex="0"><span class="pplsrsl"></span></a> </b><br /><b><br /></b><br /><pre>NAME<br />       dmesg - print or control the kernel ring buffer<br /><br />SYNOPSIS<br />      dmesg [ -c ] [ -n level ] [ -s bufsize ]<br /><br />DESCRIPTION<br />       dmesg is  used  to  examine  or  control  the kernel ring<br />       buffer.<br /></pre>Upon boot, the dmesg output is from the kernel booting, showing the devices it has found and if it has been able to configure them at all (aside from userland configuration). This log is also available in the  file <tt>/var/log/dmesg</tt>.<br /><br /><br />The main purpose of <strong>dmesg </strong>is to display kernel  messages. dmesg can provide helpful information in case of hardware  problems or problems with loading a module into the kernel. In addition,  with dmesg, you can determine what hardware is installed on your  server. During every boot, Linux checks your hardware and logs  information about it. You can view these logs using the command <strong>/bin/dmesg</strong>.<br /> <br /> <h2><span style="color: #333399;">Clearing the kernel ring buffer</span></h2><br /> If you want you can backup the logs using <strong>dmesg &gt; filename </strong>before  clearing it. Just execute the following command to clear and frest  start the ring buffer loggin (make sure you have logged in as root).<br /> <br /> <ul><li><span style="color: #333333;"><strong># dmesg -c</strong></span></li></ul><br /> Execute the command <strong>dmesg </strong>to make sure the logs are cleared. Check <strong>man dmesg </strong>for more help.<br /> <br /></div>