---
layout: post
title: SMP vs AMP
date: '2013-02-24T03:05:00.002+05:00'
author: Abbas Raza
tags: 
modified_time: '2013-02-25T06:02:49.336+05:00'
blogger_id: tag:blogger.com,1999:blog-3367966882409306161.post-1765420565040895865
blogger_orig_url: https://abbas-raza.blogspot.com/2013/02/smp-vs-amp.html
---

<div dir="ltr" style="text-align: left;" trbidi="on"><br /><div style="background-color: white; color: #333333; font-family: Georgia, Times, 'Times New Roman', serif; font-size: 15px; line-height: 1.48em; margin-bottom: 1em; margin-top: 1em; text-align: -webkit-auto;"></div><h1 class="page-title" style="color: #242424; font-family: Arial, 'Helvetica Neue', Helvetica, sans-serif; font-size: 22px; height: auto; line-height: 1.2; margin-bottom: 10px; margin-left: 0px; margin-right: 0px; margin-top: 5px;">Symmetric Multiprocessing Vs. Asymmetric Processing</h1><div class="pm-cont-main" id="content" style="font-family: Arial, 'Helvetica Neue', Helvetica, sans-serif; font-size: 14px; line-height: normal;"><div class="pm-cont-pdg" id="pm-main-pdg"><div class="node node-article node-article-page page-content clearfix clearfix" id="node-37911"><div class="content-tools" style="margin-bottom: 1em; overflow-x: hidden; overflow-y: hidden; width: 595px;"><div class="byline-date"><div class="byline" style="font-size: 12px; line-height: 1.3;"></div></div></div></div></div></div><br />Engineers contemplating a migration from a single-core to a multicore processor must identify where parallelism exists in their application. The next decision is how to partition the code over the cores of the device. The two main options are symmetric-multiprocessor (SMP) mode and asymmetric-multiprocessor (AMP) mode.<br />In some cases, combinations of these make sense as well. There’s just one kernel in SMP mode, and it’s run by all cores. <b style="background-color: #ea9999;">In AMP mode, each core has its own copy of a kernel, which could be different (heterogeneous operating systems) from, or identical (homogenous operating systems) to, the one the other core is executing.</b><br /><b><br /></b><span style="background-color: #ea9999;"><b>In SMP mode, a single operating system (OS) runs on all processors, which access a single image of the OS in the memory</b>.</span> The OS is responsible for extracting parallelism in the application. It dynamically partitions tasks across the processors, manages the ordering of task completion, and controls the sharing of all resources between the cores.<br />The latter point is important, especially if there isn’t a one-to-one relationship of chip resources (such as memory controllers) to cores. In this case, the OS will dedicate one core to “own” the resource and alert others if they need to know, but the user needn’t know which core owns the resource.<br />To the user, the program appears to run on a single processor, and much of the chip complexity is “under the hood” of the OS. This is the simplest programming model. It’s frequently used to scale the performance of an application that has parallelism (i.e., processes), but isn’t inherently parallel (as is the case when managing data streams originating from millions of separate users).<br />Performance will scale less than linearly with the number of cores put in place. In fact, the incremental value of adding another core approaches zero as the high degree of intercore communication eventually overwhelms the gain adding the core.<br />In AMP mode, the processor cores in the device are largely unaware of each other. Separate OS images exist in main memory, though there may be a shared location for interprocessor communications. AMP may take the form of multiple instances of the same non-SMP-aware OS.<br />Or, different OSs may reside on the two cores. For example, if two previously separate processors are being collapsed onto one dual-core device, different OSs may reside on the two cores.<br />In another usage model for AMP, a statically partitioned, task-offload arrangement-one core manages the computationally intensive calculations while the other runs the main OS. This arrangement sometimes is used with a real-time OS (RTOS), which forwards packets, and the Linux OS, which implements higher-level applications.<br />In any of these three cases, the user must pay attention to the resource sharing between the two OSs. Neither OS owns the entire chip, so resource sharing isn’t “under the hood” as in SMP mode.<br />If there’s a single instance of a resource on the multicore device, one core typically “owns” it. That means it receives interrupts and error messages and would be responsible, at the application-level, for passing the required information to the other core.<br />AMP has some advantages, though. It’s the only approach that works when two separate OSs are in place. Also, resources can be dedicated to critical tasks, resulting in more deterministic performance. And it often has higher performance than SMP, because the cores spend less time handshaking with each other.<br />The decision to use SMP or AMP largely will be about what’s easiest to implement. Applications that already run on an SMP-aware OS, such as Linux, can easily scale by adding more cores under SMP. AMP is a good choice if the application has obvious parallelism that’s easily partitioned to the number of cores at the user level.<br />Networked multiprocessing is an asymmetric implementation mostly found in embedded architectures where the system typically has a network connection, shared bus, or shared mailbox for communication between processing elements. Otherwise, the main memory isn’t shared.</div>