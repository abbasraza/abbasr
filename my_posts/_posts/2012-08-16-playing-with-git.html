---
layout: post
title: Playing with GIT
date: '2012-08-16T15:33:00.000+05:00'
author: Abbas Raza
tags:
- git
modified_time: '2012-08-16T15:42:15.922+05:00'
blogger_id: tag:blogger.com,1999:blog-3367966882409306161.post-2292578286932004789
blogger_orig_url: https://abbas-raza.blogspot.com/2012/08/playing-with-git.html
---

<div dir="ltr" style="text-align: left;" trbidi="on"><br /><span style="font-family: 'Courier New', Courier, monospace;">Here are some concepts that will help you understand Git.  If you are  in a hurry, you can skip this section and come back when you get  confused - you should be able to pick up a lot about Git with just your  intuition. </span><br /><span style="font-family: 'Courier New', Courier, monospace;"><br /></span><br /><span style="font-family: 'Courier New', Courier, monospace;"><b><u>Checkouts and Repositories</u></b>&nbsp;Each Subversion project has one <i>central repository</i> which stores all the history.  Everyone has a checkout of the repository, which they <i>update from</i> and <i>commit to</i>.  Each Git project gives everyone a <i>personal repository</i>, and lets them <i>pull from</i> and <i>push to</i> each other.  Many Git projects use an "official" repository that they agree to treat like an SVN repository. </span><br /><span style="font-family: 'Courier New', Courier, monospace;"><br /></span><br /><span style="font-family: 'Courier New', Courier, monospace;"><b><u>URLs and paths</u></b>&nbsp;In Subversion, a <i>URL</i> identifies the location of the repository, and the path inside the repository identifies the branch or tag.  So <tt>svn://svn.example.com/trunk</tt> might be the URL for the <tt>trunk</tt> branch of your repository.  In Git, the <i>URL</i> is still the location of a repository, but branches and tags are labels you access with Git commands.  So <tt>git://git.example.com/</tt> might be the URL for a whole Git repository. </span><br /><span style="font-family: 'Courier New', Courier, monospace;"><br /></span><br /><span style="font-family: 'Courier New', Courier, monospace;"><b><u>Visualize</u></b>&nbsp;Git version history can get complicated, especially in big projects.  You may like to look at your repository with the <b><code>gitk</code></b> viewer to understand what's going on. </span><br /><span style="font-family: 'Courier New', Courier, monospace;"><br /></span><br /><span style="font-family: 'Courier New', Courier, monospace;"><b><u>Revisions</u></b>&nbsp;Subversion identifies revisions with numbers  starting at 1 and going up in each revision.  That's fine when one  central repository keeps track of all the numbers, but who decides the  next revision number if everyone has their own repository?  Git uses  unique 40-character identifiers instead - <a class="external text" href="http://en.wikipedia.org/wiki/SHA-1" rel="nofollow">SHA-1 hashes</a>  that you can think of as random strings.  These numbers look kinda  scary, but you don't actually use them that often.  Git has nicknames  for the commits you use most often, has relative names for other  interesting commits, and lets you refer to the rest by the first  half-dozen characters in their identifier.  For example, your current  commit is always called <b><code>HEAD</code></b>, the parent of the current commit is <b><code>HEAD^</code></b> and the grandparent is <b><code>HEAD^^</code></b> (you can go on adding carets).  The commit <b><code>abc123def456abc789def012abc345def678abc9</code></b> can be referred to as <b><code>abc123</code></b> (and you can use <b><code>abc123^</code></b>, <b><code>abc123^^</code></b> etc.).  See the <a class="external text" href="http://www.kernel.org/pub/software/scm/git/docs/git-rev-parse.html" rel="nofollow">git-rev-parse manpage</a> if you want to know which commit <b><code>trunk@{'tea-time last Wednesday}~2</code></b> refers to.&nbsp;</span><br /><span style="font-family: 'Courier New', Courier, monospace;"><br /></span><br /><br /><h1><span class="mw-headline" id="Creating_a_New_Repository"><span style="font-family: 'Courier New', Courier, monospace;">Creating a New Repository </span></span></h1><span style="font-family: 'Courier New', Courier, monospace;">Let's step through how you create and update a new project in Git and SVN. </span><br /><span style="font-family: 'Courier New', Courier, monospace;">If you are creating a new project, you would: </span><br /><table style="border-collapse: collapse; border: 1px dashed #2F6FAB; width: 100%;"><tbody><tr> <td style="background-color: #e0ecf9; padding: 0 2em; width: 50%;"><span style="font-family: 'Courier New', Courier, monospace;"><b><tt>mkdir <i>myproject</i>; cd <i>myproject</i><br />git init</tt></b> </span></td><td style="background-color: #f9f9f9; padding: 0 2em; width: 50%;"><span style="font-family: 'Courier New', Courier, monospace;"><tt>svnadmin create <i>myproject_repo</i><br />svn checkout <i>file://myproject_repo</i> <i>myproject</i></tt> </span></td></tr></tbody></table><span style="font-family: 'Courier New', Courier, monospace;">If you are putting an existing project under version control, you would <code>cd</code> to your project directory, then: </span><br /><table style="border-collapse: collapse; border: 1px dashed #2F6FAB; width: 100%;"><tbody><tr> <td style="background-color: #e0ecf9; padding: 0 2em; width: 50%;"><span style="font-family: 'Courier New', Courier, monospace;"><b><tt>git init<br />git add .<br />git commit</tt></b> </span></td><td style="background-color: #f9f9f9; padding: 0 2em; width: 50%;"><span style="font-family: 'Courier New', Courier, monospace;"><tt>svnadmin create <i>myproject_repo</i><br />svn import . <i>myproject_repo</i></tt> </span></td></tr></tbody></table><span style="font-family: 'Courier New', Courier, monospace;"><b><code>git init</code></b> initializes the repository, <b><code>git add .</code></b> adds all the files under the current directory and <b><code>git commit</code></b> creates the initial import. </span><br /><span style="font-family: 'Courier New', Courier, monospace;">Remember - Git does not have separate places for a repository and  your working copy - the working copy always already contains the  repository as well, in the <code>.git</code> subdirectory. (Of course you can have special repositories that do not have a working copy attached - <i>bare</i>  repositories. These are useful for having a repo over at some server  where you don't do any actual work but which serves just for pushing and  pulling.) </span><br /><span style="font-family: 'Courier New', Courier, monospace;">If you are downloading someone else's Git project, you would do this instead: </span><br /><table align="center" style="border-collapse: collapse; border: 1px dashed #2F6FAB; width: 100%;"><tbody><tr> <td style="background-color: #e0ecf9; padding: 0 2em; width: 50%;"><span style="font-family: 'Courier New', Courier, monospace;"><b><tt style="white-space: pre;">git clone <i>url</i> <i>myproject</i></tt></b><br /></span></td><td style="background-color: #f9f9f9; padding: 0 2em; width: 50%;"><span style="font-family: 'Courier New', Courier, monospace;"><tt>svn checkout <i>url</i></tt> </span></td></tr></tbody></table><span style="font-family: 'Courier New', Courier, monospace;">Or to download an SVN project into Git: </span><br /><table align="center" style="border-collapse: collapse; border: 1px dashed #2F6FAB; width: 100%;"><tbody><tr> <td style="background-color: #e0ecf9; padding: 0 2em; width: 50%;"><span style="font-family: 'Courier New', Courier, monospace;"><b><tt style="white-space: pre;">git svn clone --stdlayout <i>url</i> <i>myproject</i></tt></b><br /></span></td><td style="background-color: #f9f9f9; padding: 0 2em; width: 50%;"><span style="font-family: 'Courier New', Courier, monospace;"><tt>svn checkout <i>url</i></tt> </span></td></tr></tbody></table><span style="font-family: 'Courier New', Courier, monospace;"><b><code>git clone</code></b> and <b><code>git svn clone</code></b> download the complete contents of a remote repository and create a local copy of it.  <b><code>--stdlayout</code></b> tells Git that it should look in the standard <code>trunk</code>/<code>tags</code>/<code>branches</code> directories for branches (see the <a class="external text" href="http://www.kernel.org/pub/software/scm/git/docs/git-svn.html" rel="nofollow">git-svn</a> manual if your project uses a different layout). </span><br /><span style="font-family: 'Courier New', Courier, monospace;">Now your tree is officially tracked by Git.  One nice thing to  note - no matter how many subdirectories your project has, there's only  one <b><code>.git</code></b> directory that contains all the version  control information.  Do some random changes to your tree now - poke  around in a few files or something.&nbsp;</span><br /><br /><h1> <span class="mw-headline" id="Making_Changes"><span style="font-family: 'Courier New', Courier, monospace;">&nbsp;Making Changes </span></span></h1><span style="font-family: 'Courier New', Courier, monospace;">When you've edited some files, next you add them to version control.  First you check what you've done: </span><br /><table style="border-collapse: collapse; border: 1px dashed #2F6FAB; width: 100%;"><tbody><tr> <td style="background-color: #e0ecf9; padding: 0 2em; width: 50%;"><span style="font-family: 'Courier New', Courier, monospace;"><b><tt>git diff</tt></b> </span></td><td style="background-color: #f9f9f9; padding: 0 2em; width: 50%;"><span style="font-family: 'Courier New', Courier, monospace;"><tt>svn diff | less</tt> </span></td></tr></tbody></table><span style="font-family: 'Courier New', Courier, monospace;">That's it.  This is one of the more powerful commands.  To get a diff with a specific revision and path do: </span><br /><table style="border-collapse: collapse; border: 1px dashed #2F6FAB; width: 100%;"><tbody><tr> <td style="background-color: #e0ecf9; padding: 0 2em; width: 50%;"><span style="font-family: 'Courier New', Courier, monospace;"><b><tt>git diff <i>rev</i> <i>path</i></tt></b> </span></td><td style="background-color: #f9f9f9; padding: 0 2em; width: 50%;"><span style="font-family: 'Courier New', Courier, monospace;"><tt>svn diff -r<i>rev</i> <i>path</i></tt> </span></td></tr></tbody></table><span style="font-family: 'Courier New', Courier, monospace;">There is a more concise representation of changes available: </span><br /><table style="border-collapse: collapse; border: 1px dashed #2F6FAB; width: 100%;"><tbody><tr> <td style="background-color: #e0ecf9; padding: 0 2em; width: 50%;"><span style="font-family: 'Courier New', Courier, monospace;"><b><tt>git status</tt></b> </span></td><td style="background-color: #f9f9f9; padding: 0 2em; width: 50%;"><span style="font-family: 'Courier New', Courier, monospace;"><tt>svn status</tt> </span></td></tr></tbody></table><span style="font-family: 'Courier New', Courier, monospace;">This will show the concise changes summary as well as list any files  that you haven't either ignored or told Git about.  In addition, it will  also show at the top which branch you are in. </span><br /><span style="font-family: 'Courier New', Courier, monospace;">The <b><code>status</code></b> command also shows the "untracked files" that Git doesn't know what to do with.  You can handle these by: </span><br /><table style="border-collapse: collapse; border: 1px dashed #2F6FAB; width: 100%;"><tbody><tr> <td style="background-color: #e0ecf9; padding: 0 2em; width: 50%;"><span style="font-family: 'Courier New', Courier, monospace;"><b><tt>git clean<br />git add <i>files</i><br />$EDITOR .gitignore</tt></b> </span></td><td style="background-color: #f9f9f9; padding: 0 2em; width: 50%;"><span style="font-family: 'Courier New', Courier, monospace;"><tt>rm -rf <i>files</i><br />svn add <i>files</i><br />svn propedit svn:ignore .</tt> </span></td></tr></tbody></table><span style="font-family: 'Courier New', Courier, monospace;">In fact you need to tell Git when you add, move or remove any files, just like SVN: </span><br /><table style="border-collapse: collapse; border: 1px dashed #2F6FAB; width: 100%;"><tbody><tr> <td style="background-color: #e0ecf9; padding: 0 2em; width: 50%;"><span style="font-family: 'Courier New', Courier, monospace;"><b><tt>git add <i>file</i><br />git rm <i>file</i><br />git mv <i>file</i></tt></b> </span></td><td style="background-color: #f9f9f9; padding: 0 2em; width: 50%;"><span style="font-family: 'Courier New', Courier, monospace;"><tt>svn add <i>file</i><br />svn rm <i>file</i><br />svn mv <i>file</i></tt> </span></td></tr></tbody></table><span style="font-family: 'Courier New', Courier, monospace;">You can also recursively add/remove whole directories and so on; Git's cool! </span><br /><span style="font-family: 'Courier New', Courier, monospace;">If you made changes to a file that you want to undo, you can get back the last version you committed: </span><br /><table style="border-collapse: collapse; border: 1px dashed #2F6FAB; width: 100%;"><tbody><tr> <td style="background-color: #e0ecf9; padding: 0 2em; width: 50%;"><span style="font-family: 'Courier New', Courier, monospace;"><b><tt>git checkout <i>path</i></tt></b> </span></td><td style="background-color: #f9f9f9; padding: 0 2em; width: 50%;"><span style="font-family: 'Courier New', Courier, monospace;"><tt>svn revert <i>path</i></tt> </span></td></tr></tbody></table><span style="font-family: 'Courier New', Courier, monospace;">So, it's about time for us to commit our changes: </span><br /><table style="border-collapse: collapse; border: 1px dashed #2F6FAB; width: 100%;"><tbody><tr> <td style="background-color: #e0ecf9; padding: 0 2em; width: 50%;"><span style="font-family: 'Courier New', Courier, monospace;"><b><tt>git commit -a</tt></b> </span></td><td style="background-color: #f9f9f9; padding: 0 2em; width: 50%;"><span style="font-family: 'Courier New', Courier, monospace;"><tt>svn commit</tt> </span></td></tr></tbody></table><span style="font-family: 'Courier New', Courier, monospace;">This looks the same, but there are two important differences: </span><br /><span style="font-family: 'Courier New', Courier, monospace;">First, you have to specify <b><code>-a</code></b> if you want to commit <i>all</i> your files, instead of just those files you've recently done a <b><code>git add</code></b> or <b><code>git rm</code></b> on.  This can be frustrating at first, but several important techniques are based on it (for example, <b><code>git add -p</code></b> lets you add part of a file - see the <a class="external text" href="http://www.kernel.org/pub/software/scm/git/docs/git-add.html" rel="nofollow">git-add</a> manual page for details). </span><br /><span style="font-family: 'Courier New', Courier, monospace;">Second, Git commits are <i>private</i> by default - they aren't  pushed to any central server.  We'll talk about pushing changes later,  but private commits have some important benefits.  For example, when you  realise you left some debugging in your last commit, or made a typo in  the commit message, you can do <b><code>git commit --amend</code></b> to fix it, or even do <b><code>git reset HEAD^</code></b> to toss the commit away completely without affecting your files. </span><br /><span style="font-family: 'Courier New', Courier, monospace;">A few words about the commit message: it is <i>customary</i> to  have a short commit summary as the first line of the message, because  many tools just show the first line of the message.  You can specify the  commit message using the <b><code>-m</code></b> parameter (extra <b><code>-m</code></b> arguments will create extra paragraphs in the commit message). </span><br /><h1> <span class="mw-headline" id="Browsing"><span style="font-family: 'Courier New', Courier, monospace;"> Browsing </span></span></h1><span style="font-family: 'Courier New', Courier, monospace;">Now that we have committed some stuff, you might want to review your history: </span><br /><table style="border-collapse: collapse; border: 1px dashed #2F6FAB; width: 100%;"><tbody><tr> <td style="background-color: #e0ecf9; padding: 0 2em; width: 50%;"><span style="font-family: 'Courier New', Courier, monospace;"><b><tt>git log<br />git blame <i>file</i></tt></b> </span></td><td style="background-color: #f9f9f9; padding: 0 2em; width: 50%;"><span style="font-family: 'Courier New', Courier, monospace;"><tt>svn log | less<br />svn blame <i>file</i></tt> </span></td></tr></tbody></table><span style="font-family: 'Courier New', Courier, monospace;">The <b><code>log</code></b> command is more powerful than in SVN.  For example, <b><code>git log --oneline</code></b> only shows the first few characters of each commit ID and the first line of each commit message.  See the <a class="external text" href="http://www.kernel.org/pub/software/scm/git/docs/git-log.html" rel="nofollow">git-log manual page</a> for more stuff <b><code>git log</code></b> can do. </span><br /><span style="font-family: 'Courier New', Courier, monospace;">The <b><code>blame</code></b> command is also more powerful than  SVN, as it can track changes even across file copies and renames.  But  you probably want to do something different!  When you used <code>svn blame</code>, you were probably only interested in the history of a few lines of code.  <b><code>git log -p</code></b> will show the changes to the file in each revision (so you can search for the code you're interested in), and <b><code>git log -S<i>string</i></code></b> will show just the commits which add or remove text matching <i>string</i>. </span><br /><span style="font-family: 'Courier New', Courier, monospace;">You can see the contents of a file, the listing of a directory or a commit with: </span><br /><table style="border-collapse: collapse; border: 1px dashed #2F6FAB; width: 100%;"><tbody><tr> <td style="background-color: #e0ecf9; padding: 0 2em; width: 50%;"><span style="font-family: 'Courier New', Courier, monospace;"><b><tt>git show <i>rev</i>:<i>path/to/file</i><br />git show <i>rev</i>:<i>path/to/directory</i><br />git show -s <i>rev</i><br />git show <i>rev</i></tt></b> </span></td><td style="background-color: #f9f9f9; padding: 0 2em; width: 50%;"><span style="font-family: 'Courier New', Courier, monospace;"><tt>svn cat <i>url</i><br />svn list <i>url</i><br />svn log -r<i>rev</i> <i>url</i><br />svn diff -c<i>rev</i> <i>url</i></tt> </span></td></tr></tbody></table><h1> <span class="mw-headline" id="Branching_and_Tagging"><span style="font-family: 'Courier New', Courier, monospace;"> Branching and Tagging </span></span></h1><span style="font-family: 'Courier New', Courier, monospace;">Subversion marks certain checkpoints in history by copying directories.  The copy is usually placed in a directory called <code>tags</code> (if it's a tag) or <code>branches</code> (if it's a branch).  Git marks checkpoints in history by applying a label to a commit.  For example, the file <b><code>.git/HEAD</code></b> is the label for the current commit, and <b><code>.git/refs/heads/master</code></b>  is the label for the main development branch.  Git branches and tags  take some getting used to, but are more powerful when you do. </span><br /><span style="font-family: 'Courier New', Courier, monospace;">In Subversion, you create a branch by copying your project to a subdirectory.  In Git, you tell it, well, to create a branch: </span><br /><table style="border-collapse: collapse; border: 1px dashed #2F6FAB; width: 100%;"><tbody><tr> <td style="background-color: #e0ecf9; padding: 0 2em; width: 50%;"><span style="font-family: 'Courier New', Courier, monospace;"><b><tt>git branch <i>new_branch</i> <i>old_branch</i><br /><br />git checkout <i>new_branch</i></tt></b> </span></td><td style="background-color: #f9f9f9; padding: 0 2em; width: 50%;"><span style="font-family: 'Courier New', Courier, monospace;"><tt style="white-space: pre;">~: svn copy svn://svn.example.com/<i>old_branch</i> \    svn://svn.example.com/branches/<i>new_branch</i>   ~: svn switch svn://svn.example.com/branches/<i>new_branch</i></tt> </span></td></tr></tbody></table><span style="font-family: 'Courier New', Courier, monospace;">The first command creates a branch, the second command switches your  tree to a certain branch.  You can pass an extra argument to <code>git branch</code> to base your new branch on a different revision than the latest one. </span><br /><span style="font-family: 'Courier New', Courier, monospace;">Running <code>git branch</code> without arguments lists your branches.  The <b><code>*</code></b> in the output marks the current branch. </span><br /><table style="border-collapse: collapse; border: 1px dashed #2F6FAB; width: 100%;"><tbody><tr> <td style="background-color: #e0ecf9; padding: 0 2em; width: 50%;"><span style="font-family: 'Courier New', Courier, monospace;"><b><tt>git branch</tt></b> </span></td><td style="background-color: #f9f9f9; padding: 0 2em; width: 50%;"><span style="font-family: 'Courier New', Courier, monospace;"><tt>svn list svn://svn.example.com/branches/</tt> </span></td></tr></tbody></table><span style="font-family: 'Courier New', Courier, monospace;">To move your tree to some older revision, use: </span><br /><table style="border-collapse: collapse; border: 1px dashed #2F6FAB; width: 100%;"><tbody><tr> <td style="background-color: #e0ecf9; padding: 0 2em; width: 50%;"><span style="font-family: 'Courier New', Courier, monospace;"><b><tt>git checkout <i>rev</i><br />git checkout <i>branch</i></tt></b> </span></td><td style="background-color: #f9f9f9; padding: 0 2em; width: 50%;"><span style="font-family: 'Courier New', Courier, monospace;"><tt>svn update -r <i>rev</i><br />svn update</tt> </span></td></tr></tbody></table><span style="font-family: 'Courier New', Courier, monospace;">Git's behaviour when you check an older revision out can be a bit  confusing, but also kinda cool.  SVN would say you are now on an older  revision of the same branch, because you have checked out older files in  the same directory.  But because a Git branch is just a label for a  commit, Git would say you are <i>not on any branch at all</i>.  SVN  would also say that you can't commit until you update your branch to its  rightful place.  Git will let you commit as much as you like, although  you can get in trouble if you don't know what you're doing. </span><br /><span style="font-family: 'Courier New', Courier, monospace;">When you are not on a branch, you are known as having a <i>detached HEAD</i>  (i.e. your HEAD commit is not attached to any branch).  This is one of  the few things in Git that has earnt its scary name - if you make  commits on a detached HEAD, then you do <b><code>git checkout some_branch</code></b>, what <b><code>git checkout</code></b> command would you use to get your commits back?  You should almost always do <b><code>git checkout -b <i>new_branch</i></code></b> before you make any commits, so you can get back easily later on.  In other words, be careful and don't lose your HEAD. </span><br /><span style="font-family: 'Courier New', Courier, monospace;">Git tags are fairly similar to Git branches, but with some extra  tricks.  Git tags can have a date, committer, and message that act just  like the equivalents for Git commits.  They can also be signed with a  PGP key if you really want to stamp them with your seal of approval.   This is great if you want to release a public version of your work,  because you can have one place to store your release announcement and  your guarantee that the code hasn't been tampered with.  So, let's do  it: </span><br /><table style="border-collapse: collapse; border: 1px dashed #2F6FAB; width: 100%;"><tbody><tr> <td style="background-color: #e0ecf9; padding: 0 2em; width: 50%;"><span style="font-family: 'Courier New', Courier, monospace;"><b><tt>git tag -a <i>name</i></tt></b> </span></td><td style="background-color: #f9f9f9; padding: 0 2em; width: 50%;"><span style="font-family: 'Courier New', Courier, monospace;"><tt style="white-space: pre;">~: svn copy svn://svn.example.com/trunk \    svn://svn.example.com/tags/<i>name</i></tt> </span></td></tr></tbody></table><span style="font-family: 'Courier New', Courier, monospace;">To list tags and to show a tag message: </span><br /><table style="border-collapse: collapse; border: 1px dashed #2F6FAB; width: 100%;"><tbody><tr> <td style="background-color: #e0ecf9; padding: 0 2em; width: 50%;"><span style="font-family: 'Courier New', Courier, monospace;"><b><tt>git tag -l<br />git show <i>tag</i></tt></b> </span></td><td style="background-color: #f9f9f9; padding: 0 2em; width: 50%;"><span style="font-family: 'Courier New', Courier, monospace;"><tt style="white-space: pre;">~: svn list svn://svn.example.com/<i>tags/</i>  ~: svn log --limit 1  svn://svn.example.com/tags/<i>tag</i></tt> </span></td></tr></tbody></table><h1> <span class="mw-headline" id="Merging"><span style="font-family: 'Courier New', Courier, monospace;"> Merging </span></span></h1><span style="font-family: 'Courier New', Courier, monospace;">Git supports merging much better than Subversion - both branches have  their history preserved over the merges, and you don't have to keep  track of which revision you were at last time when you merge again.   Unfortunately, you lose much of this power if you use <a class="external text" href="http://www.kernel.org/pub/software/scm/git/docs/git-svn.html" rel="nofollow">git-svn</a> to share your work with an SVN server. </span><br /><span style="font-family: 'Courier New', Courier, monospace;">If you are not using <b><code>git-svn</code></b>, make sure you are on one of the to-be-merged branches and merge the other one now: </span><br /><table style="border-collapse: collapse; border: 1px dashed #2F6FAB; width: 100%;"><tbody><tr> <td style="background-color: #e0ecf9; padding: 0 2em; width: 50%;"><span style="font-family: 'Courier New', Courier, monospace;"><b><tt>git merge <i>branch</i></tt></b> </span></td><td style="background-color: #f9f9f9; padding: 0 2em; width: 50%;"><span style="font-family: 'Courier New', Courier, monospace;"><i>(assuming you want to merge everything since revision 20)</i><br /><tt style="white-space: pre;">svn merge -r 20:HEAD \ svn://svn.example.com/branches/<i>branch</i></tt></span></td></tr></tbody></table><span style="font-family: 'Courier New', Courier, monospace;">If changes were made on only one of the branches since the last  merge, they are simply replayed on your other branch (a so-called <i>fast-forward merge</i>).  If changes were made on both branches, they are merged intelligently (a so-called <i>three-way merge</i>).  If the three-way merge doesn't have any merge conflicts, it makes a commit with a convenient log message (the <b><code>--no-commit</code></b> option disables this).  If there are merge conflicts, <b><code>git merge</code></b> will report them and let you resolve them. </span><br /><span style="font-family: 'Courier New', Courier, monospace;">When you have merge conflicts, you usually want to see a diff of just the conflicting changes.  <b><code>git diff</code></b> doesn't normally show changes that have been marked with <b><code>git add</code></b>, so Git automatically <b><code>add</code></b>s all the files that didn't conflict, giving you a nice small diff.  You can do <b><code>git diff --cached</code></b> if you just want to see the non-conflicting changes, or <b><code>git diff HEAD</code></b> if you want to see everything. </span><br /><span style="font-family: 'Courier New', Courier, monospace;">Like with SVN, you need to tell Git when you have resolved your conflicts: </span><br /><table style="border-collapse: collapse; border: 1px dashed #2F6FAB; width: 100%;"><tbody><tr> <td style="background-color: #e0ecf9; padding: 0 2em; width: 50%;"><span style="font-family: 'Courier New', Courier, monospace;"><b><tt>git add <i>file</i></tt></b> </span></td><td style="background-color: #f9f9f9; padding: 0 2em; width: 50%;"><span style="font-family: 'Courier New', Courier, monospace;"><tt>svn resolved <i>file</i></tt> </span></td></tr></tbody></table><span style="font-family: 'Courier New', Courier, monospace;">This has the nice side-effect that files disappear from <b><code>git diff</code></b> as you resolve them. </span><br /><span style="font-family: 'Courier New', Courier, monospace;">Aside from merging, sometimes you want to just pluck one commit out of a different branch.  To apply the changes in revision <i>rev</i> and commit them to the current branch use: </span><br /><table style="border-collapse: collapse; border: 1px dashed #2F6FAB; width: 100%;"><tbody><tr> <td style="background-color: #e0ecf9; padding: 0 2em; width: 50%;"><span style="font-family: 'Courier New', Courier, monospace;"><b><tt>git cherry-pick <i>rev</i></tt></b> </span></td><td style="background-color: #f9f9f9; padding: 0 2em; width: 50%;"><span style="font-family: 'Courier New', Courier, monospace;"><tt>svn merge -c <i>rev</i> <i>url</i></tt> </span></td></tr></tbody></table><h1> <span class="mw-headline" id="Going_Remote"><span style="font-family: 'Courier New', Courier, monospace;"> Going Remote </span></span></h1><span style="font-family: 'Courier New', Courier, monospace;">So far, we haven't talked much about how Git is a <i>distributed</i> version control system.  It is time for us to set the record straight. </span><br /><span style="font-family: 'Courier New', Courier, monospace;">If you created your repository with one of the <b><code>clone</code></b> commands, Git will have already set up a remote repository for you called <b><code>origin</code></b>.  If you created your repository from scratch, you might want to skip this section and come back to it later. </span><br /><span style="font-family: 'Courier New', Courier, monospace;">When you cloned your repository, Git downloaded all the branches and tags in that repository, and created your <b><code>master</code></b> branch based on the <b><code>master</code></b> branch in that repository (or the <b><code>trunk</code></b> branch if you used <b><code>git svn clone</code></b>).  Even though it only used the <b><code>master</code></b> branch, it kept copies of all the others in case you needed them.  Copies of branches from a remote repository are called <i>remote branches</i>, and don't behave quite like the <i>local branches</i> you've used before. </span><br /><span style="font-family: 'Courier New', Courier, monospace;">For starters, remote branches don't show up in a normal <b><code>git branch</code></b>.  Instead, you list remote branches with <b><code>git branch -r</code></b>.  You can <b><code>log</code></b> these branches, <b><code>diff</code></b> them and <b><code>merge</code></b>  them, but you can't commit to them, or they would stop being copies of  the branch on the remote repository.  If you want to work with a remote  branch, you need to create a local branch that "tracks" it: </span><br /><table style="border-collapse: collapse; border: 1px dashed #2F6FAB; width: 100%;"><tbody><tr> <td style="background-color: #e0ecf9; padding: 0 2em; width: 50%;"><span style="font-family: 'Courier New', Courier, monospace;"><b><tt>git checkout -t origin/<i>branch</i></tt></b> </span></td><td style="background-color: #f9f9f9; padding: 0 2em; width: 50%;"><span style="font-family: 'Courier New', Courier, monospace;"><tt>svn switch <i>url</i></tt> </span></td></tr></tbody></table><span style="font-family: 'Courier New', Courier, monospace;">Now, how do you download new changes from a remote repository?  You fetch them with <b><code>git fetch</code></b> (or <b><code>git svn fetch</code></b>).  But usually you don't just want to fetch, you also want to merge any changes into your local branch: </span><br /><table style="border-collapse: collapse; border: 1px dashed #2F6FAB; width: 100%;"><tbody><tr> <td style="background-color: #e0ecf9; padding: 0 2em; width: 50%;"><span style="font-family: 'Courier New', Courier, monospace;"><b><tt>git pull</tt></b> </span></td><td style="background-color: #f9f9f9; padding: 0 2em; width: 50%;"><span style="font-family: 'Courier New', Courier, monospace;"><tt>svn update</tt> </span></td></tr></tbody></table><span style="font-family: 'Courier New', Courier, monospace;">Again, <b><code>git-svn</code></b> does this a bit differently: </span><br /><table style="border-collapse: collapse; border: 1px dashed #2F6FAB; width: 100%;"><tbody><tr> <td style="background-color: #e0ecf9; padding: 0 2em; width: 50%;"><span style="font-family: 'Courier New', Courier, monospace;"><b><tt>git svn rebase</tt></b> </span></td><td style="background-color: #f9f9f9; padding: 0 2em; width: 50%;"><span style="font-family: 'Courier New', Courier, monospace;"><tt>svn update</tt> </span></td></tr></tbody></table><span style="font-family: 'Courier New', Courier, monospace;">A <i>pull</i> is technically a bit different to a <i>rebase</i>.  As always, see the  <a class="external text" href="http://www.kernel.org/pub/software/scm/git/docs/git-pull.html" rel="nofollow">relevant</a> <a class="external text" href="http://www.kernel.org/pub/software/scm/git/docs/git-merge.html" rel="nofollow">manual</a> <a class="external text" href="http://www.kernel.org/pub/software/scm/git/docs/git-rebase.html" rel="nofollow">pages</a> for details. </span><br /><span style="font-family: 'Courier New', Courier, monospace;">An <a class="external text" href="http://www.cuni.cz/~obo/git-branching-illustrated/" rel="nofollow">illustrated example on branching and merging</a> may help you as well. </span><br /><h1> <span class="mw-headline" id="Sharing_your_Work"><span style="font-family: 'Courier New', Courier, monospace;"> Sharing your Work </span></span></h1><span style="font-family: 'Courier New', Courier, monospace;">We saw in the previous section that you can <i>pull</i> other  people's work into your repository, but how do your changes get back  out?  Well, your Git repository is as good as any other repository, so  you could just ask people to <b><code>git pull</code></b> from you the same way you <b><code>git pull</code></b>ed  from them.  This is fine as far as Git's concerned, but what if you  have a slow Internet connection, or you are behind a firewall, or you  like to amend your commits before letting people see them?  Most people  get around this by having two repositories: a private repository they  work on, and a public repository for people to pull from.  Some people  prefer to share one public repository between the whole team, which is  basically the same as having one central SVN repository. </span><br /><span style="font-family: 'Courier New', Courier, monospace;">So how do you get your work onto your public repository?  Well, it's the opposite of <b><code>git pull</code></b>, so you <b><code>git push</code></b>!  Of course, <b><code>git-svn</code></b> is different as usual: <b><code>git svn dcommit</code></b>. </span><br /><span style="font-family: 'Courier New', Courier, monospace;">Public repositories are generally accessible over SSH or HTTP.   SSH is more secure, and it's highly recommended to put your SSH key into  an SSH agent (such as <code>ssh-agent</code> or PuTTY's <code>pageant</code>) so you don't have to type it in all the time. </span><br /><span style="font-family: 'Courier New', Courier, monospace;">If you need to create your own public repository, you should read the <a class="external text" href="http://www.kernel.org/pub/software/scm/git/docs/user-manual.html#public-git-repositories" rel="nofollow">section on public repositories</a> in the Git User's Manual.  It's worth emphasising that the manual will get you to make a <i>bare repository</i> - this is effectively just a <b><code>.git</code></b>  directory with no files checked out.  Bare repositories save space and  remove the temptation to work directly on repositories that get pushed  to (what would you expect to happen if someone pushed changes into a  branch while you're working on it?). </span><br /><span style="font-family: 'Courier New', Courier, monospace;">Finally, some projects hardly bother with public repositories at  all - they just e-mail their commits to each other!  In fact development  for Git itself is done largely by people sending commits to the mailing  list.  You can create patches with <b><code>git format-patch</code></b> and apply them with <b><code>git am</code></b>.  To maintain a set of patches, you can use <strong>StGIT</strong> (see the <a class="external text" href="http://git.or.cz/course/stgit.html" rel="nofollow">StGIT Crash Course</a> for details).&nbsp;</span><br /><br /><h1> <span class="mw-headline" id="Making_Changes"></span></h1><br /></div>