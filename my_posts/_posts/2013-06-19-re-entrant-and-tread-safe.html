---
layout: post
title: Re-entrant and Tread safe
date: '2013-06-19T03:39:00.001+05:00'
author: Abbas Raza
tags: 
modified_time: '2013-06-19T03:39:21.798+05:00'
blogger_id: tag:blogger.com,1999:blog-3367966882409306161.post-2367004135754827029
blogger_orig_url: https://abbas-raza.blogspot.com/2013/06/re-entrant-and-tread-safe.html
---

<div dir="ltr" style="text-align: left;" trbidi="on"><br />Re-entrance and thread-safety are two different concepts that can be  associated with good programming practices. In this article we will try  and understand both the concepts and their differences with the help of  some code snippets.<br /><span id="more-11100"></span><br /> <h3>1. Thread Safe Code</h3>As the name suggests, a piece of code is thread safe when more than  one thread can execute the same code without causing synchronization  problems. Lets look at the following code snippet :<br /> <pre>...<br />...<br />...<br /><br />char arr[10];<br />int index=0;<br /><br />int func(char c)<br />{<br />    int i=0;<br />    if(index &gt;= sizeof(arr))<br />    {<br />        printf("\n No storage\n");<br />        return -1;<br />    }<br />    arr[index] = c;<br />    index++;<br />    return index;<br />}<br /><br />...<br />...<br />...</pre>The above function populates the array ‘arr’ with the character value  passed to it as argument and then updates the ‘index’ variable so that  subsequent calls to this function write on the updated index of the  array.<br /> Suppose this function is being used by two threads. Now, lets assume  that thread one calls this function and updates the array index with  value ‘c’. Now, before updating the ‘index’ suppose second thread gets  the execution control and it also calls this function. Now since the  index was not updated by thread one , so this thread writes on the same  index and hence overwrites the value written by thread one.<br /> So we see that lack of synchronization between the threads was the root cause of this problem.<br /> Now, lets make this function thread safe :<br /> <pre>...<br />...<br />...<br /><br />char arr[10];<br />int index=0;<br /><br />int func(char c)<br />{<br />    int i=0;<br />    if(index &gt;= sizeof(arr))<br />    {<br />        printf("\n No storage\n");<br />        return -1;<br />    }<br /><br />    /* ...<br />       Lock a mutex here<br />       ...<br />    */<br /><br />   &nbsp;arr[index] = c;<br />    index++;<br /><br />    /* ...<br />       unlock the mutex here<br />       ...<br />    */<br /><br />    return index;<br />}<br /><br />...<br />...<br />...</pre>What we did above is that we made the array and index updates an  atomic operation using the mutex locks. Now even if multiple threads are  trying to use this function, there would be no synchronization problems  as any thread which acquire the mutex will complete both the operations  (array and index update) before any other thread acquires the mutex.<br />     <center>      <div style="margin-bottom: 10px; margin-left: 2px; margin-top: 10px;">                             </div></center>So now the above piece of code becomes thread-safe.<br /> <h3>2. Re-entrant Code</h3>The concept of re-entrant code is slightly different from thread safe  code. Usually in a single thread of execution if a function is called  then before the completion of execution of that particular function, the  flow cannot move ahead. But, there are some situations where in a  single thread also the execution of a function can be interrupted by a  call to same function again. So a piece of code that can successfully  handle the this scenario is known as a re-entrant code. Lets look at the  example below :<br /> <pre>...<br />...<br />...<br /><br />char *s;<br /><br />void func()<br />{<br />    int new_length = 0;<br /><br />    // initialize 'new_length'<br />    // with some new value here<br /><br />    char *ptr = realloc(s, new_length);<br /><br />    if(ptr)<br />    {<br />        s = ptr;<br />    }<br />    else<br />    {<br />        //Report Failure<br />    }<br /><br />    // do some stuff here<br />}<br /><br />...<br />...<br />...</pre>if we analyze the re-entrance capability of the above code, we find  that this code is not re-entrant. This is because of the fact that the  above code is buggy in the sense that if the same function is being used  by a signal handler (in response to handling of some signals) then in  the situation where a call to function func() was between realloc() and  the ‘if’ condition next to it and then this execution is interrupted by a  call to this function from signal handler. In this scenario since ‘s’  is not updated with new allocated address so realloc might fail (or  program might even crash).<br /> So we see that the above code is not re-entrant. A re-entrant code is  least expected to work with global variables. Following is an example  of a re-entrant code:<br /> <pre>...<br />...<br />...<br /><br />int exchange_values(int *ptr1, int *ptr2)<br />{<br />    int tmp;<br /><br />    tmp = *ptr1;<br />    *ptr1 = *ptr2;<br />    *ptr2 = *tmp;<br /><br />    return 0;<br />}<br /><br />...<br />...<br />...</pre><h3>3. Thread Safe but not Re-entrant</h3>A piece of code can be thread safe but it’s not necessary that its re-entrant. Look at the following code :<br /> <pre>...<br />...<br />...<br /><br />int func()<br />{<br />    int ret = 0;<br /><br />    // Lock Mutex here<br /><br />    // Play with some<br />    // global data structures<br />    // here   <br /><br />    // Unlock mutex<br /><br />    return ret;<br />}<br /><br />...<br />...<br />...</pre>In the example above, since the critical section is protected by  mutex so the code above is thread safe but its not re-entrant because if  the execution of the above function is interrupted through some signal  handler (calling the same function while handling a signal) then (if  non-recursive mutexes are being used) the first execution is interrupted  while the second execution will wait forever to acquire mutex. So  overall the complete program will hang.<br /> <h3>4. Re-entrant but not Thread Safe</h3>Re-entrance is something which is associated with a function whose  first execution gets interrupted by second call to it (from within the  same thread) and this first execution resumes when the second execution  completes. This is not the case with threads which can keep on stepping  onto another thread’s toes multiple times. So if a function is  re-entrant then it does not guarantee that its thread safe.<br /></div>