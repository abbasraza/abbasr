---
layout: post
title: linux kernel boot process (Boot time optimizations)
date: '2013-09-27T19:17:00.002+05:00'
author: Abbas Raza
tags: 
modified_time: '2013-09-27T19:17:59.663+05:00'
blogger_id: tag:blogger.com,1999:blog-3367966882409306161.post-4604641931942990322
blogger_orig_url: https://abbas-raza.blogspot.com/2013/09/linux-kernel-boot-process-boot-time.html
---

<div dir="ltr" style="text-align: left;" trbidi="on"><br /><small><span style="font-family: Verdana, sans-serif; font-size: x-small;">starting from start_kernel <br />      <br />      0) scheduler init routine creates idle thread<br />      1) rest_init() is called from start_kernel()<br />      2&nbsp; 2 threads are created kernel_init and kthreadd<br />      3) schedule() called for first time<br />      4) kthreadd scheduled first by cfs scheduler<br />      5) kthreadd looks if there is any new thread to be created<br />      6) since there is no new thread to be created so it set state       TASK_INTERRUPTIBLE and calls schedule()<br />      7) now kernel_init is picked by scheduler<br />      8) kernel_init calls do_pre_smp_initcalls<br />      9) when spawn_ksoftirqd initcall is run by kernel init thread, it       goes to create a kthread(ksoftirqd)<br />      10) for this it wakes up kthreadd<br />      11) a new kthread is created by kthreadd<br />      12) kthreadd looks if any other kthread to be created in create       list<br />      13) since there is no kthread to be created so it calls scheduler       with state TASK_INTERRUPTIBLE<br />      14) now scheduler picks kernel init thread to br executed next<br />      15) kernel init thread calls wait_for_completion(&amp;create.done)       which is supposed to be set by newly created kthread.<br />      16) schedule timeout occurs and scheduler next picks newly created       kthread.<br />      17) newly created kthread sets state TASK_UNINTERRUPTIBLE and       sends complete signal create.done <br />      18) scheduler then schedules kernel init thread which goes to bind       this newly created kthread to cpu0 using kbind().<br />      19) kernel init thread checks if newly created kthread has been       dequeued.<br />      20) if not dequeued yet, it means its still in run queue.<br />      21) if 20 is yes then kernel init goes to sleep <br />      <br />      for HZ=100, it sleeps for 10ms while for HZ=1000, it sleeps for       1ms<br />      <br />      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (unlikely(on_rq)) {<br />      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ktime_t to = ktime_set(0,       NSEC_PER_SEC/HZ);<br />      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; set_current_state(TASK_UNINTERRUPTIBLE);<br />      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; schedule_hrtimeout(&amp;to,       HRTIMER_MODE_REL);<br />      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; continue;<br />      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />      <br />      22) Now scheduler picks newly created kthread from run queue.<br />      23) this kthread is dequeues by calling schedule with       TASK_UNINTERRUPTIBLE state set<br />      24) Now at this time all the kthreads are in dequeued state except       idle i.e<br />      <br />      kthreadd --&gt; dequeued<br />      kernel init --&gt; dequeued<br />      kthread (ksoftirqd) --&gt; dequeued<br />      <br />      25) Nothing left on run queue so scheduler calls idle thread.<br />      26) Now system runs in idle thread until 1 timer tick is received       i.e for 10ms (HZ=100)<br />      27) when 1 timer tick is received, system get out from idle thread<br />      28) scheduler wakes up kernel init thread <br />      29) kernel init thread again checks if kthread (ksoftirqd) has       been dequeued <br />      30) if it founds it dequeued, it finally binds it with cpu0<br />      31) kernel init continues execution and kthread (ksoftirqd) is       woken up and put on run queue again for cpu0.<br />      <br />      <br />      <br />      So 1 timer tick is always consumed in idle loop in step 21 while       booting whenever there is a need to bind a kthread to cpu. The       same thing happens with<br />      initcalls init_workqueues and cpu_stop_init causing the boot time       to increase.<br />      <br />      <br />      Possible solutions to decrease the boot time:<br />      ==============================================<br />      1) Increasing the timer ticks i.e HZ=1000 which will cause step 21       to sleep for only 1ms.<br />      draw back: increasing timer ticks decreases throughput<br />      <br />      OR<br />      <br />      2) Changes in scheduler core, modifying the step 21 to never sleep<br />      <br />      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (unlikely(on_rq)) {<br />      &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; schedule();<br />      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; continue;<br />      &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br />      draw back: not known yet<br />      <br />      OR<br />      <br />      3) Changes in scheduler core, modifying the step 21 to sleep for       smaller time (1ms in case of HZ=100) but for this i guess we will       need hrtimer to work at that time. But it was found that hrtimer       does not work at that time for any resolution higher that 10ms(in       case of HZ=100).<br />      <br />      draw back: not known yet</span></small></div>