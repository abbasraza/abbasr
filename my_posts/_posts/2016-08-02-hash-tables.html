---
layout: post
title: Hash tables
date: '2016-08-02T15:27:00.001+05:00'
author: Abbas Raza
tags: 
modified_time: '2016-08-02T15:27:38.035+05:00'
blogger_id: tag:blogger.com,1999:blog-3367966882409306161.post-4863312802828622518
blogger_orig_url: https://abbas-raza.blogspot.com/2016/08/hash-tables.html
---

<div dir="ltr" style="text-align: left;" trbidi="on"><div class="js-gist-file-update-container js-task-list-container file-box" style="background-color: white; box-sizing: border-box; color: #333333; font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, Roboto, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;; font-size: 14px; line-height: 21px;"><div class="file" id="file-hash-md" style="border-radius: 3px; border: 1px solid rgb(221, 221, 221); box-sizing: border-box; margin-bottom: 15px; margin-top: 20px; position: relative;"><div class="readme blob instapaper_body" id="readme" style="box-sizing: border-box;"><article class="markdown-body entry-content" itemprop="text" style="border-radius: 0px; border: 0px; box-sizing: border-box; font-size: 16px; line-height: 1.5; padding: 45px; word-wrap: break-word;"><h1 style="border-bottom-color: rgb(238, 238, 238); border-bottom-style: solid; border-bottom-width: 1px; box-sizing: border-box; font-size: 2em; line-height: 1.25; margin-bottom: 16px; margin-left: 0px; margin-right: 0px; margin-top: 0px !important; padding-bottom: 0.3em;">What is a hash and how does it work</h1><div style="box-sizing: border-box; margin-bottom: 16px;">Let us start from a practical example. Imagine we are writing a traffic monitoring application. The purpose of application would be to calculate a number of bytes sent by each IP address. To do that, let create a structure that does that accounting:</div><pre style="background-color: #f7f7f7; border-radius: 3px; box-sizing: border-box; font-family: Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; font-size: 13.6px; font-stretch: normal; line-height: 1.45; margin-bottom: 16px; overflow: auto; padding: 16px; word-wrap: normal;"><code style="background: transparent; border-radius: 3px; border: 0px; box-sizing: border-box; display: inline; font-family: Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; font-size: 13.6px; line-height: inherit; margin: 0px; overflow: visible; padding: 0px; word-break: normal; word-wrap: normal;">struct ipstat {<br />  uint32_t ip;      /* Source IP address */<br />  unsinged bytes;   /* Bytes sent        */<br />};<br /></code></pre><div style="box-sizing: border-box; margin-bottom: 16px;">So, the application would have a set of such structures, one for every IP address seen. When IP packet arrives, we must:</div><ol style="box-sizing: border-box; margin-bottom: 16px; margin-top: 0px; padding-left: 2em;"><li style="box-sizing: border-box;">find the structure in set</li><li style="box-sizing: border-box; margin-top: 0.25em;">if not found, allocate new structure, and add to set</li><li style="box-sizing: border-box; margin-top: 0.25em;">for the found structure, increment 'bytes' by the packet length.</li></ol><div style="box-sizing: border-box; margin-bottom: 16px;">The easiest way of doing that is to organize the structures in a linked list:</div><pre style="background-color: #f7f7f7; border-radius: 3px; box-sizing: border-box; font-family: Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; font-size: 13.6px; font-stretch: normal; line-height: 1.45; margin-bottom: 16px; overflow: auto; padding: 16px; word-wrap: normal;"><code style="background: transparent; border-radius: 3px; border: 0px; box-sizing: border-box; display: inline; font-family: Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; font-size: 13.6px; line-height: inherit; margin: 0px; overflow: visible; padding: 0px; word-break: normal; word-wrap: normal;">struct ipstat {<br />  struct ipstat *next;  /* Next in list */<br />  uint32_t ip;          /* IP address   */<br />  unsigned  bytes;      /* Bytes sent   */<br />};<br /></code></pre><div style="box-sizing: border-box; margin-bottom: 16px;">That would work fine, if the number of structures in a list is reasonably small. Step (1) would require scanning a whole linked list:</div><pre style="background-color: #f7f7f7; border-radius: 3px; box-sizing: border-box; font-family: Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; font-size: 13.6px; font-stretch: normal; line-height: 1.45; margin-bottom: 16px; overflow: auto; padding: 16px; word-wrap: normal;"><code style="background: transparent; border-radius: 3px; border: 0px; box-sizing: border-box; display: inline; font-family: Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; font-size: 13.6px; line-height: inherit; margin: 0px; overflow: visible; padding: 0px; word-break: normal; word-wrap: normal;">struct ipstat *lookup(uint32_t ip) {<br />  struct ipstat *p;<br />  for (p = head; p != NULL; p = p-&gt;next) {<br />    if (p-&gt;ip == ip) return p;<br />  }<br />  return NULL;<br />}<br /></code></pre><div style="box-sizing: border-box; margin-bottom: 16px;">Fast networks can generate many thousands packets a second. If the diversity of traffic is high, our list may contain thousands entries. That means, we must do a lookup (i.e. call&nbsp;<code style="background-color: rgba(0, 0, 0, 0.0392157); border-radius: 3px; box-sizing: border-box; font-family: Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; font-size: 13.6px; margin: 0px; padding: 0.2em 0px;">lookup()</code>&nbsp;function) many thousands times a second. It should be fast. The linked list implementation shown above is not fast. It is actually almost the slowest possible, beacuse it does a linear scan through all elements of the list.</div><div style="box-sizing: border-box; margin-bottom: 16px;">What can be done to make this function faster ?</div><div style="box-sizing: border-box; margin-bottom: 16px;">Well, it could be optimized this way: for every successful lookup, we move the element to the head of the list. So next time we lookup, it can be found faster. This way, the linked list will self-organize: the 'rarely seen' nodes will be pushed to the end of list, and the 'popular' ones will be at the beginning.</div><div style="box-sizing: border-box; margin-bottom: 16px;">Done that, it is hard to predict what would be the average lookup time: that depends on nature of traffic. In some cases, it might be enough. This is the case when only very small number of machines are active on the network, while others are idle.</div><div style="box-sizing: border-box; margin-bottom: 16px;">In general, to provide fast lookup, the set should be organized in different way. By lookup in this case I mean 'find struct ipstat by given IP address'. What would be the fastest way? The fastest possible is index lookup. Let's create an array:</div><pre style="background-color: #f7f7f7; border-radius: 3px; box-sizing: border-box; font-family: Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; font-size: 13.6px; font-stretch: normal; line-height: 1.45; margin-bottom: 16px; overflow: auto; padding: 16px; word-wrap: normal;"><code style="background: transparent; border-radius: 3px; border: 0px; box-sizing: border-box; display: inline; font-family: Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; font-size: 13.6px; line-height: inherit; margin: 0px; overflow: visible; padding: 0px; word-break: normal; word-wrap: normal;">#define IPRANGE 4294967296<br />struct ipstat   *array[IPRANGE];<br /></code></pre><div style="box-sizing: border-box; margin-bottom: 16px;">IP address is 32-bit integer, so the range on possible IP addresses are from&nbsp;<code style="background-color: rgba(0, 0, 0, 0.0392157); border-radius: 3px; box-sizing: border-box; font-family: Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; font-size: 13.6px; margin: 0px; padding: 0.2em 0px;">0</code>&nbsp;to&nbsp;<code style="background-color: rgba(0, 0, 0, 0.0392157); border-radius: 3px; box-sizing: border-box; font-family: Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; font-size: 13.6px; margin: 0px; padding: 0.2em 0px;">4294967296</code>. We create array of pointers to struct ipstat, and for every incoming packet do a lookup:</div><pre style="background-color: #f7f7f7; border-radius: 3px; box-sizing: border-box; font-family: Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; font-size: 13.6px; font-stretch: normal; line-height: 1.45; margin-bottom: 16px; overflow: auto; padding: 16px; word-wrap: normal;"><code style="background: transparent; border-radius: 3px; border: 0px; box-sizing: border-box; display: inline; font-family: Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; font-size: 13.6px; line-height: inherit; margin: 0px; overflow: visible; padding: 0px; word-break: normal; word-wrap: normal;">struct ipstat *lookup(uint32_t ip) {<br />  return array[ip];<br />}<br /></code></pre><div style="box-sizing: border-box; margin-bottom: 16px;">Yes, this is lightning fast - the fastest possible way of findind the value&nbsp;<code style="background-color: rgba(0, 0, 0, 0.0392157); border-radius: 3px; box-sizing: border-box; font-family: Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; font-size: 13.6px; margin: 0px; padding: 0.2em 0px;">struct ipstat *</code>&nbsp;by associated key&nbsp;<code style="background-color: rgba(0, 0, 0, 0.0392157); border-radius: 3px; box-sizing: border-box; font-family: Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; font-size: 13.6px; margin: 0px; padding: 0.2em 0px;">uint32_t ip</code>. The only problem with that is memory&nbsp;<code style="background-color: rgba(0, 0, 0, 0.0392157); border-radius: 3px; box-sizing: border-box; font-family: Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; font-size: 13.6px; margin: 0px; padding: 0.2em 0px;">struct ipstat *array[IPRANGE]</code>&nbsp;would take.</div><div style="box-sizing: border-box; margin-bottom: 16px;">On 32-bit machine, it is 4Gb * sizeof(pointer), so 16 Gigabytes. Not nice. The other thing is that almost all memory of that array will not be used. Array holds ~4 billion entries. We gonna see thousands IP addresses. The space would be wasted. And probably no modern operating system will allow us to allocate 16 Gb of memory for the array.</div><div style="box-sizing: border-box; margin-bottom: 16px;">What we have to do ? Well, shrink the array. Let's shrink it to, say, 1000:</div><pre style="background-color: #f7f7f7; border-radius: 3px; box-sizing: border-box; font-family: Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; font-size: 13.6px; font-stretch: normal; line-height: 1.45; margin-bottom: 16px; overflow: auto; padding: 16px; word-wrap: normal;"><code style="background: transparent; border-radius: 3px; border: 0px; box-sizing: border-box; display: inline; font-family: Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; font-size: 13.6px; line-height: inherit; margin: 0px; overflow: visible; padding: 0px; word-break: normal; word-wrap: normal;">#define SIZE    1000<br />struct ipstat   *array[SIZE];<br /></code></pre><div style="box-sizing: border-box; margin-bottom: 16px;">And, every IP address we must 'map' to this range: from&nbsp;<code style="background-color: rgba(0, 0, 0, 0.0392157); border-radius: 3px; box-sizing: border-box; font-family: Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; font-size: 13.6px; margin: 0px; padding: 0.2em 0px;">0</code>&nbsp;to&nbsp;<code style="background-color: rgba(0, 0, 0, 0.0392157); border-radius: 3px; box-sizing: border-box; font-family: Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; font-size: 13.6px; margin: 0px; padding: 0.2em 0px;">SIZE</code>. Let write the function 'hash', that does that:</div><pre style="background-color: #f7f7f7; border-radius: 3px; box-sizing: border-box; font-family: Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; font-size: 13.6px; font-stretch: normal; line-height: 1.45; margin-bottom: 16px; overflow: auto; padding: 16px; word-wrap: normal;"><code style="background: transparent; border-radius: 3px; border: 0px; box-sizing: border-box; display: inline; font-family: Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; font-size: 13.6px; line-height: inherit; margin: 0px; overflow: visible; padding: 0px; word-break: normal; word-wrap: normal;">unsigned hash(uin32_t key) {<br />  /* Map the key (ip-address) to the index in the array */<br />  return (key % SIZE);<br />}<br /></code></pre><div style="box-sizing: border-box; margin-bottom: 16px;">Now,&nbsp;<code style="background-color: rgba(0, 0, 0, 0.0392157); border-radius: 3px; box-sizing: border-box; font-family: Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; font-size: 13.6px; margin: 0px; padding: 0.2em 0px;">hash(ip)</code>&nbsp;will always return a value between 0 and SIZE - 1. Lookup function will look like this:</div><pre style="background-color: #f7f7f7; border-radius: 3px; box-sizing: border-box; font-family: Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; font-size: 13.6px; font-stretch: normal; line-height: 1.45; margin-bottom: 16px; overflow: auto; padding: 16px; word-wrap: normal;"><code style="background: transparent; border-radius: 3px; border: 0px; box-sizing: border-box; display: inline; font-family: Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; font-size: 13.6px; line-height: inherit; margin: 0px; overflow: visible; padding: 0px; word-break: normal; word-wrap: normal;">struct ipstat *lookup(uint32_t ip) {<br />  unsigned  index;<br />  index = hash(ip);<br />  return (array[index]);<br />}<br /></code></pre><div style="box-sizing: border-box; margin-bottom: 16px;">Bingo! We have done that.&nbsp;<code style="background-color: rgba(0, 0, 0, 0.0392157); border-radius: 3px; box-sizing: border-box; font-family: Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; font-size: 13.6px; margin: 0px; padding: 0.2em 0px;">lookup()</code>&nbsp;is still very fast, because the function&nbsp;<code style="background-color: rgba(0, 0, 0, 0.0392157); border-radius: 3px; box-sizing: border-box; font-family: Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; font-size: 13.6px; margin: 0px; padding: 0.2em 0px;">hash()</code>&nbsp;is very simple and fast. This method is called 'hashing', and the variable 'array' is called a 'hash table'.</div><div style="box-sizing: border-box; margin-bottom: 16px;">The only problem left, is when two or more IP addresses are mapped to the same index. This is called 'hash collision'. There are number of ways to fight that situation. One of the simplest methods is to organize collided nodes into a linked list. In this case, the hash table would not hold the values themselves, but the linked list heads. The lookup function will look like this:</div><pre style="background-color: #f7f7f7; border-radius: 3px; box-sizing: border-box; font-family: Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; font-size: 13.6px; font-stretch: normal; line-height: 1.45; margin-bottom: 16px; overflow: auto; padding: 16px; word-wrap: normal;"><code style="background: transparent; border-radius: 3px; border: 0px; box-sizing: border-box; display: inline; font-family: Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; font-size: 13.6px; line-height: inherit; margin: 0px; overflow: visible; padding: 0px; word-break: normal; word-wrap: normal;">struct ipstat *lookup(uint32_t ip) {<br />  unsigned  index = hash(ip);<br />  struct ipstat *p, *head = array[index];<br />  index = hash(ip);<br />  for (p = head; p != NULL; p = p-&gt;next) {<br />    if (p-&gt;ip == ip) return p;<br />  }<br />  return NULL;<br />}<br /></code></pre><div style="box-sizing: border-box; margin-bottom: 16px;">It looks very much like the first, linked-list based lookup function, which we said has very bad performance. Yes, it is true. The difference is that linked-list implementation holds ALL elements in one single linked list. The hash table is a set of much smaller linked lists, where each list holds the collided elements only. If the hash function is good, and it scatters the keys smoothly, the avarage length of the list would be</div><pre style="background-color: #f7f7f7; border-radius: 3px; box-sizing: border-box; font-family: Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; font-size: 13.6px; font-stretch: normal; line-height: 1.45; margin-bottom: 16px; overflow: auto; padding: 16px; word-wrap: normal;"><code style="background: transparent; border-radius: 3px; border: 0px; box-sizing: border-box; display: inline; font-family: Consolas, &quot;Liberation Mono&quot;, Menlo, Courier, monospace; font-size: 13.6px; line-height: inherit; margin: 0px; overflow: visible; padding: 0px; word-break: normal; word-wrap: normal;">TOTAL_NUMBER_OF_ELEMENTS / SIZE<br /></code></pre><div style="box-sizing: border-box; margin-bottom: 16px;">On how to choose a hash function, dynamically resizable hash tables in the next review.</div><div style="box-sizing: border-box;">Author: Sergey Lyubka, 2005</div></article></div></div></div><a href="https://www.blogger.com/null" name="comments" style="background-color: white; box-sizing: border-box; color: #4078c0; font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, Roboto, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;; font-size: 14px; line-height: 21px;"></a><span style="background-color: white; color: #333333; font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, Roboto, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;; font-size: 14px; line-height: 21px;"></span><br /><div class="discussion-timeline gist-discussion-timeline js-quote-selection-container " style="background-color: white; box-sizing: border-box; color: #333333; float: left; font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, Roboto, Helvetica, Arial, sans-serif, &quot;Apple Color Emoji&quot;, &quot;Segoe UI Emoji&quot;, &quot;Segoe UI Symbol&quot;; font-size: 14px; line-height: 21px; position: relative; width: 980px;"><div class="js-discussion js-socket-channel" data-channel="tenant:1:marked-as-read:gist:8598442" style="box-sizing: border-box;"><div class="js-timeline-marker js-updatable-content" data-last-modified="Mon, 04 Jan 2016 08:49:19 GMT" data-url="/cpq/8598442/show_partial?partial=gist%2Ftimeline_marker&amp;since=1451897359" id="partial-timeline-marker" style="box-sizing: border-box;"></div><div class="discussion-timeline-actions" style="border-top-color: rgb(243, 243, 243); border-top-style: solid; border-top-width: 2px; box-sizing: border-box;"><div class="signed-out-comment" style="background-color: #fff9ea; border-radius: 3px; border: 1px solid rgb(223, 216, 194); box-sizing: border-box; margin-left: 64px; margin-top: 15px; padding: 15px;"><a class="btn btn-primary" href="https://gist.github.com/join?source=comment-gist" rel="nofollow" style="-webkit-appearance: none; -webkit-user-select: none; background-color: #60b044; background-image: linear-gradient(rgb(138, 221, 109), rgb(96, 176, 68)); border-radius: 3px; border: 1px solid rgb(92, 169, 65); box-sizing: border-box; color: white; cursor: pointer; display: inline-block; font-weight: 600; line-height: 20px; margin-right: 3px; padding: 6px 12px; position: relative; text-decoration: none; text-shadow: rgba(0, 0, 0, 0.14902) 0px -1px 0px; vertical-align: baseline; white-space: nowrap;">Sign up for free</a></div><div><br /></div></div></div></div></div>