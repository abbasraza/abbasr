---
layout: post
title: Debugging with strace
date: '2012-05-03T23:07:00.002+05:00'
author: Abbas Raza
tags:
- strace
- linux debugging
- system call
modified_time: '2012-05-03T23:09:02.367+05:00'
blogger_id: tag:blogger.com,1999:blog-3367966882409306161.post-8666380022939661378
blogger_orig_url: https://abbas-raza.blogspot.com/2012/05/what-is-strace-strace-is-quite-simply.html
---

<div dir="ltr" style="text-align: left;" trbidi="on"><br /><h1> What is strace?</h1>Strace is quite simply a tool that traces the execution of system  calls. In its simplest form it can trace the execution of a binary from  start to end, and output a line of text with the name of the system  call, the arguments and the return value for every system call over the  lifetime of the process. <br />But it can do a lot more: <br /><ul><li><i><span style="font-family: Arial, Helvetica, sans-serif;">It can filter based on the specific system call or groups of system calls </span></i></li><li><i><span style="font-family: Arial, Helvetica, sans-serif;">It can profile the use of system calls by tallying up the  number of times a specific system call is used, and the time taken, and  the number of successes and errors. </span></i></li><li><i><span style="font-family: Arial, Helvetica, sans-serif;">It traces signals sent to the process. </span></i></li><li><i><span style="font-family: Arial, Helvetica, sans-serif;">It can attach to any running process by pid.</span></i></li></ul><br /><h1> How to use it</h1><br />The simplest way to run the "strace" would be as: <code> strace <i>command</i></code>Lets see what a simple well-known like "w" (the command that shows the users logged in and their current activities) does: <br /><br /><pre class="command_in">[root@localhost]$ strace /usr/bin/w 2&gt;&amp;1 | less<br /></pre><pre class="command_out">execve("/usr/bin/w", ["/usr/bin/w"], [/* 30 vars */]) = 0<br />brk(0)                                  = 0x603000<br />mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0)<br />= 0x2aaaaaaab000<br />uname({sys="Linux", node="oberon.anglab.com", ...}) = 0<br />access("/etc/ld.so.preload", R_OK)      = -1 ENOENT (No such<br />file or directory)<br />open("/etc/ld.so.cache", O_RDONLY)      = 3<br />fstat(3, {st_mode=S_IFREG|0644, st_size=103874, ...}) = 0<br />mmap(NULL, 103874, PROT_READ, MAP_PRIVATE, 3, 0) = 0x2aaaaaaac000<br />close(3)                                = 0<br />open("/lib64/libproc-3.2.7.so", O_RDONLY) = 3<br />read(3, "\177ELF\2\1\1\0\0\0\0\0\0\0\0\0\3\0&gt;\0\1\0\0\0\<br /> 240;`\314"..., 832) = 832<br />...<br />open("/proc/uptime", O_RDONLY)          = 3<br />lseek(3, 0, SEEK_SET)                   = 0<br />read(3, "7267.86 7230.07\n", 1023)      = 16<br />access("/var/run/utmpx", F_OK)          = -1 ENOENT (No such file<br />or directory)<br />open("/var/run/utmp", O_RDWR)           = -1 EACCES (Permission denied)<br />open("/var/run/utmp", O_RDONLY)         = 4<br />fcntl(4, F_GETFD)                       = 0<br />...<br />open("/proc", O_RDONLY|O_NONBLOCK|O_DIRECTORY) = 3<br />fstat(3, {st_mode=S_IFDIR|0555, st_size=0, ...}) = 0<br />fcntl(3, F_SETFD, FD_CLOEXEC)           = 0<br />getdents(3, /* 35 entries */, 1024)     = 1000<br />getdents(3, /* 38 entries */, 1024)     = 1016<br />stat("/proc/1", {st_mode=S_IFDIR|0555, st_size=0, ...}) = 0<br />open("/proc/1/stat", O_RDONLY)          = 4<br />read(4, "1 (init) S 0 1 1 0 -1 4194560 64"..., 1023) = 216<br />close(4)                                = 0<br />socket(PF_FILE, SOCK_STREAM, 0)         = 4<br />...<br />fcntl(5, F_SETLKW, {type=F_UNLCK, whence=SEEK_SET, start=0, len=0}) = 0<br />alarm(0)                                = 1<br />rt_sigaction(SIGALRM, {SIG_DFL}, NULL, <img alt="8)" class="wp-smiley" src="http://myhowto.org/wp-includes/images/smilies/icon_cool.gif" /> = 0<br />close(5)                                = 0<br />write(1, " 21:31:48 up  2:01,  2 users,  l"..., 281 21:31:48 up  2:01,<br />2 users,  load average: 0.00, 0.00, 0.00<br />USER     TTY      FROM              LOGIN@   IDLE   JCPU   PCPU WHAT<br />nick     pts/0    192.168.8.18     21:12    9.00s  0.03s  0.03s -bash<br />nick     pts/1    192.168.8.18     21:19    0.00s  0.13s  0.04s strace<br />/usr/bin<br />) = 281<br />exit_group(0)                           = ?<br />Process 3947 detached<br /></pre><pre class="command_out"></pre>Only a small part of the long output is shown here. As you can see,  everything starts with the "execve" syscall. Which is correct - this is  the call that executes a program in UNIX. By the way, for each of these  calls you can get more information from the manual pages - just type  "man execve" to learn more about the call and its parameters (as you can  see the parameters are shown in the trace).And, as it is supposed to  be, the execution ends with "exit_group" call with the status 0  (success). <br />You can see how the program being started loads the shared libraries it  depends on. You can see that at some point it tries to open  "var/run/utmpx" file but it does not exist (ENOENT). Then it tries to  open "/var/run/utmp" file but it is not readable for this program (i.e.  for this user) so it gets back (EACCES). Finally this program decides  that the only way to find out who is logged in is to go through all the  active processes and check where their standard input and output are  attached to. In order to do it, "w" readsthe list of files and  directories under "/proc" (open - getdents - close). By the way, the  number returned by the open() call is the file handle. By using it, you  can follow the operations with this file since all read() or write()  system calls will use the handle. After getting the list of files, "w"  goes over all process directories and reads the virtual files from there  to get more information about the processes. And fnally it displays the  results by writing them to the file descriptor 1 (standard output,  stdout). Very simple and informative. <br />There is a number of parameters that you can use with "strace" to filter  the results and get exactly the information you are looking for. For  example, if you are interested only in the network operations, lets see  what does "ping" command do (run it as root user): <br /><br /><pre class="command_in">[root@localhost]$ strace -x -e trace=network,desc ping -c 1 127.0.0.1<br /></pre><pre class="command_out">...<br />socket(PF_INET, SOCK_RAW, IPPROTO_ICMP) = 3<br />socket(PF_INET, SOCK_DGRAM, IPPROTO_IP) = 4<br />connect(4, {sa_family=AF_INET, sin_port=htons(1025), sin_addr=<br /> inet_addr("127.0.0.1")}, 16) = 0<br />getsockname(4, {sa_family=AF_INET, sin_port=htons(1028), sin_addr=<br /> inet_addr("127.0.0.1")}, [16]) = 0<br />close(4)                                = 0<br />setsockopt(3, SOL_RAW, ICMP_FILTER, ~(ICMP_ECHOREPLY|ICMP_DEST_UNREACH|<br /> ICMP_SOURCE_QUENCH|ICMP_REDIRECT|ICMP_TIME_EXCEEDED|<br /> ICMP_PARAMETERPROB),<br />4) = 0<br />setsockopt(3, SOL_IP, IP_RECVERR, [1], 4) = 0<br />setsockopt(3, SOL_SOCKET, SO_SNDBUF, [324], 4) = 0<br />setsockopt(3, SOL_SOCKET, SO_RCVBUF, [65536], 4) = 0<br />getsockopt(3, SOL_SOCKET, SO_RCVBUF, [27472947287556096], [4]) = 0<br />fstat(1, {st_mode=S_IFIFO|0600, st_size=0, ...}) = 0<br />setsockopt(3, SOL_SOCKET, SO_TIMESTAMP, [1], 4) = 0<br />setsockopt(3, SOL_SOCKET, SO_SNDTIMEO, "\x01\x00\x00\x00\x00\x00<br /> \x00\x00\x00\x00\x00\x00\x00\x00"..., 16) = 0<br />setsockopt(3, SOL_SOCKET, SO_RCVTIMEO, "\x01\x00\x00\x00\x00\x00<br /> \x00\x00\x00\x00\x00\x00\x00\x00"..., 16) = 0<br />ioctl(1, SNDCTL_TMR_TIMEBASE or TCGETS, 0x7fff418a7c90) = -1<br /> EINVAL (Invalid argument)<br />sendmsg(3, {msg_name(16)={sa_family=AF_INET, sin_port=htons(0),<br /> sin_addr=inet_addr("127.0.0.1")}, msg_iov(1)=[{"\x08\x00<br /> \xc7\x8b\xd6\x10\x00\x01\x86\x16\xa0\x46\x00\x00"..., 64}],<br /> msg_controllen=0, msg_flags=0}, 0) = 64<br />recvmsg(3, {msg_name(16)={sa_family=AF_INET, sin_port=htons(0),<br /> sin_addr=inet_addr("127.0.0.1")}, msg_iov(1)=[{"\x45<br /> \x00\x00\x54\xed\xd5\x00\x00\x40\x01\x8e\xd1\x7f\x00"..., 192}],<br /> msg_controllen=32, {cmsg_len=32, cmsg_level=SOL_SOCKET,<br /> cmsg_type=0x1d /* SCM_??? */, ...}, msg_flags=0}, 0) = 84<br />write(1, "PING 127.0.0.1 (127.0.0.1) 56(84"..., 106PING<br /> 127.0.0.1 (127.0.0.1) 56(84) bytes of data.<br />64 bytes from 127.0.0.1: icmp_seq=1 ttl=64 time=0.321 ms<br />) = 106<br />write(1, "\n", 1<br />)                       = 1<br />write(1, "--- 127.0.0.1 ping statistics --"..., 144---<br /> 127.0.0.1 ping statistics ---<br />1 packets transmitted, 1 received, 0% packet loss, time 0ms<br />rtt min/avg/max/mdev = 0.321/0.321/0.321/0.000 ms<br />) = 144<br />Process 4310 detached<br /></pre><pre class="command_out"></pre>"-e" option allows to specify what kind(s) of system calls you are interested in. <br />As you can see, this program opes 2 network sockets (with the  descriptors 3 and 4). One of them is used only to do getsockname() call  (do "man getsockname" to get more information on this call) and then it  gets closed. The one associated with the descriptor 3 is used to send  and receive raw IP traffic (this is the way to send the packets using  the protocols different from UDP and TCP). It configures the socket  using a number of options and then finally sends an IP packet (sendmsg)  to the given destination. You can even see part of the message data  ("-x" option requests strace to display the hex numbers instead of  non-ASCII strings). If you want to see the complete data you may want to  use "-s" option to set the maximum string length you want to be  displayed. After sending the message it gets back the response  (recvmsg). Then it displays the output of the program. <br />You can use "-o" option with the file name argument to redirect the  output to a text file. Usually when analyzing more complicated examples  it is easier to get the trace into a file first and then study this file  using text editor or "grep" command.<br /><br /><br /><h2> Different Uses:</h2><br /><br /><h2> 1) Find out which config files a program reads on startup</h2>Ever tried figuring out why some program doesn't read the config file  you thought it should? Had to wrestle with custom compiled or  distro-specific binaries that read their config from what you consider  the "wrong" location? <br />The naive approach: <br /><pre>$ strace php 2&gt;&amp;1 | grep php.ini<br />open("/usr/local/bin/php.ini", O_RDONLY) = -1 ENOENT (No such file or directory)<br />open("/usr/local/lib/php.ini", O_RDONLY) = 4<br />lstat64("/usr/local/lib/php.ini", {st_mode=S_IFLNK|0777, st_size=27, ...}) = 0<br />readlink("/usr/local/lib/php.ini", "/usr/local/Zend/etc/php.ini", 4096) = 27<br />lstat64("/usr/local/Zend/etc/php.ini", {st_mode=S_IFREG|0664, st_size=40971, ...}) = 0<br /></pre>So this version of PHP reads php.ini from /usr/local/lib/php.ini (but it tries /usr/local/bin first). <br />The more sophisticated approach if I only care about a specific syscall: <br /><br /><pre>$ strace -e open php 2&gt;&amp;1 | grep php.ini<br />open("/usr/local/bin/php.ini", O_RDONLY) = -1 ENOENT (No such file or directory)<br />open("/usr/local/lib/php.ini", O_RDONLY) = 4<br /></pre>The same approach work for a lot of other things. Have multiple  versions of a library installed at different paths and wonder exactly  which actually gets loaded? etc. <br /><br /><br /><br /><h2> 2) Why does this program not open my file?</h2>Ever run into a program that silently refuse to read a file it  doesn't have read access to, but you only figured out after swearing for  ages because you thought it didn't actually find the file? Well, you  already know what to do: <br /><br /><pre>$ strace -e open,access 2&gt;&amp;1 | grep your-filename<br /></pre>Look for an open() or access() syscall that fails <br /><br /><br /><h2> 3) What is that process doing RIGHT NOW?</h2>Ever had a process suddenly hog lots of CPU? Or had a process seem to be hanging? <br />Then you find the pid, and do this: <br /><br /><pre>root@dev:~# strace -p 15427<br />Process 15427 attached - interrupt to quit<br />futex(0x402f4900, FUTEX_WAIT, 2, NULL <unfinished ...=""><br />Process 15427 detached<br /></unfinished></pre>Ah. So in this case it's hanging in a call to futex(). Incidentally  in this case it doesn't tell us all that much - hanging on a futex can  be caused by a lot of things (a futex is a locking mechanism in the  Linux kernel). The above is from a normally working but idle Apache  child process that's just waiting to be handed a request. <br />But "strace -p" is highly useful because it removes a lot of  guesswork, and often removes the need for restarting an app with more  extensive logging (or even recompile it). <br /><br /><br /><br /><br /><h2> 4) What is taking time?</h2>You can always recompile an app with profiling turned on, and for  accurate information, especially about what parts of your own code that  is taking time that is what you should do. But often it is tremendously  useful to be able to just quickly attach strace to a process to see what  it's <strong>currently</strong> spending time on, especially to  diagnose problems. Is that 90% CPU use because it's actually doing real  work, or is something spinning out of control. <br />Here's what you do: <br /><br /><pre>root@dev:~# strace -c -p 11084<br />Process 11084 attached - interrupt to quit<br />Process 11084 detached<br />% time     seconds  usecs/call     calls    errors syscall<br />------ ----------- ----------- --------- --------- ----------------<br /> 94.59    0.001014          48        21           select<br />  2.89    0.000031           1        21           getppid<br />  2.52    0.000027           1        21           time<br />------ ----------- ----------- --------- --------- ----------------<br />100.00    0.001072                    63           total<br />root@dev:~# <br /></pre>After you've started strace with -c -p you just wait for as long as  you care to, and then exit with ctrl-c. Strace will spit out profiling  data as above. <br />In this case, it's an idle Postgres "postmaster" process that's  spending most of it's time quietly waiting in select(). In this case  it's calling getppid() and time() in between each select() call, which  is a fairly standard event loop. <br />You can also run this "start to finish", here with "ls": <br /><br /><pre>root@dev:~# strace -c &gt;/dev/null ls<br />% time     seconds  usecs/call     calls    errors syscall<br />------ ----------- ----------- --------- --------- ----------------<br /> 23.62    0.000205         103         2           getdents64<br /> 18.78    0.000163          15        11         1 open<br /> 15.09    0.000131          19         7           read<br /> 12.79    0.000111           7        16           old_mmap<br />  7.03    0.000061           6        11           close<br />  4.84    0.000042          11         4           munmap<br />  4.84    0.000042          11         4           mmap2<br />  4.03    0.000035           6         6         6 access<br />  3.80    0.000033           3        11           fstat64<br />  1.38    0.000012           3         4           brk<br />  0.92    0.000008           3         3         3 ioctl<br />  0.69    0.000006           6         1           uname<br />  0.58    0.000005           5         1           set_thread_area<br />  0.35    0.000003           3         1           write<br />  0.35    0.000003           3         1           rt_sigaction<br />  0.35    0.000003           3         1           fcntl64<br />  0.23    0.000002           2         1           getrlimit<br />  0.23    0.000002           2         1           set_tid_address<br />  0.12    0.000001           1         1           rt_sigprocmask<br />------ ----------- ----------- --------- --------- ----------------<br />100.00    0.000868                    87        10 total<br /></pre>Pretty much what you'd expect, it spents most of it's time in two  calls to read the directory entries (only two since it was run on a  small directory). <br /><br /><h2> 5) Why the **** can't I connect to that server?</h2>Debugging why some process isn't connecting to a remote server can be  exceedingly frustrating. DNS can fail, connect can hang, the server  might send something unexpected back etc. You can use tcpdump to analyze  a lot of that, and that too is a very nice tool, but a lot of the time  strace will give you less chatter, simply because it will only ever  return data related to the syscalls generated by "your" process. If  you're trying to figure out what one of hundreds of running processes  connecting to the same database server does for example (where picking  out the right connection with tcpdump is a nightmare), strace makes life  a lot easier. <br />This is an example of a trace of "nc" connecting to www.news.com on port 80 without any problems: <br /><br /><pre>$ strace -e poll,select,connect,recvfrom,sendto nc www.news.com 80<br />sendto(3, "\24\0\0\0\26\0\1\3\255\373NH\0\0\0\0\0\0\0\0", 20, 0, {sa_family=AF_NETLINK, pid=0, groups=00000000}, 12) = 20<br />connect(3, {sa_family=AF_FILE, path="/var/run/nscd/socket"}, 110) = -1 ENOENT (No such file or directory)<br />connect(3, {sa_family=AF_FILE, path="/var/run/nscd/socket"}, 110) = -1 ENOENT (No such file or directory)<br />connect(3, {sa_family=AF_INET, sin_port=htons(53), sin_addr=inet_addr("62.30.112.39")}, 28) = 0<br />poll([{fd=3, events=POLLOUT, revents=POLLOUT}], 1, 0) = 1<br />sendto(3, "\213\321\1\0\0\1\0\0\0\0\0\0\3www\4news\3com\0\0\34\0\1", 30, MSG_NOSIGNAL, NULL, 0) = 30<br />poll([{fd=3, events=POLLIN, revents=POLLIN}], 1, 5000) = 1<br />recvfrom(3, "\213\321\201\200\0\1\0\1\0\1\0\0\3www\4news\3com\0\0\34\0\1\300\f"..., 1024, 0, {sa_family=AF_INET, sin_port=htons(53), sin_addr=inet_addr("62.30.112.39")}, [16]) = 153<br />connect(3, {sa_family=AF_INET, sin_port=htons(53), sin_addr=inet_addr("62.30.112.39")}, 28) = 0<br />poll([{fd=3, events=POLLOUT, revents=POLLOUT}], 1, 0) = 1<br />sendto(3, "k\374\1\0\0\1\0\0\0\0\0\0\3www\4news\3com\0\0\1\0\1", 30, MSG_NOSIGNAL, NULL, 0) = 30<br />poll([{fd=3, events=POLLIN, revents=POLLIN}], 1, 5000) = 1<br />recvfrom(3, "k\374\201\200\0\1\0\2\0\0\0\0\3www\4news\3com\0\0\1\0\1\300\f"..., 1024, 0, {sa_family=AF_INET, sin_port=htons(53), sin_addr=inet_addr("62.30.112.39")}, [16]) = 106<br />connect(3, {sa_family=AF_INET, sin_port=htons(53), sin_addr=inet_addr("62.30.112.39")}, 28) = 0<br />poll([{fd=3, events=POLLOUT, revents=POLLOUT}], 1, 0) = 1<br />sendto(3, "\\\2\1\0\0\1\0\0\0\0\0\0\3www\4news\3com\0\0\1\0\1", 30, MSG_NOSIGNAL, NULL, 0) = 30<br />poll([{fd=3, events=POLLIN, revents=POLLIN}], 1, 5000) = 1<br />recvfrom(3, "\\\2\201\200\0\1\0\2\0\0\0\0\3www\4news\3com\0\0\1\0\1\300\f"..., 1024, 0, {sa_family=AF_INET, sin_port=htons(53), sin_addr=inet_addr("62.30.112.39")}, [16]) = 106<br />connect(3, {sa_family=AF_INET, sin_port=htons(80), sin_addr=inet_addr("216.239.122.102")}, 16) = -1 EINPROGRESS (Operation now in progress)<br />select(4, NULL, [3], NULL, NULL)        = 1 (out [3])<br /></pre>So what happens here? <br />Notice the connection attempts to /var/run/nscd/socket? They mean  nc first tries to connect to NSCD - the Name Service Cache Daemon -  which is usually used in setups that rely on NIS, YP, LDAP or similar  directory protocols for name lookups. In this case the connects fails. <br />It then moves on to DNS (DNS is port 53, hence the  "sin_port=htons(53)" in the following connect. You can see it then does a  "sendto()" call, sending a DNS packet that contains www.news.com. It  then reads back a packet. For whatever reason it tries three times, the  last with a slightly different request. My best guess why in this case  is that www.news.com is a CNAME (an "alias"), and the multiple requests  may just be an artifact of how nc deals with that. <br />Then in the end, it finally issues a connect() to the IP it  found. Notice it returns EINPROGRESS. That means the connect was  non-blocking - nc wants to go on processing. It then calls select(),  which succeeds when the connection was successful. <br />Try adding "read" and "write" to the list of syscalls given to  strace and enter a string when connected, and you'll get something like  this: <br /><br /><pre>read(0, "test\n", 1024)                 = 5<br />write(3, "test\n", 5)                   = 5<br />poll([{fd=3, events=POLLIN, revents=POLLIN}, {fd=0, events=POLLIN}], 2, -1) = 1<br />read(3, "<br />This shows it reading "test" + linefeed from standard in, and writing it back out to the network connection, then calling poll() to wait for a reply, reading the reply from the network connection and writing it to standard out. Everything seems to be working right.<br /><br /><br /><br /><br />References:<br /><br />http://www.hokstad.com/5-simple-ways-to-troubleshoot-using-strace.html<br /><br />http://myhowto.org/solving-problems/7-exploring-system-internals-with-lsof-and-strace/<br /><br /><br /></pre></div>