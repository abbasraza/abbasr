---
layout: post
title: Configuring SMP IRQ Affinity
date: '2013-02-24T03:02:00.001+05:00'
author: Abbas Raza
tags: 
modified_time: '2013-02-24T03:02:58.101+05:00'
thumbnail: http://2.bp.blogspot.com/-lRqUzMgU2iM/USk5xmdiauI/AAAAAAAAAM4/R-Rnzdjw25Y/s72-c/Screenshot-1.png
blogger_id: tag:blogger.com,1999:blog-3367966882409306161.post-2041679548035051364
blogger_orig_url: https://abbas-raza.blogspot.com/2013/02/configuring-smp-irq-affinity.html
---

<div dir="ltr" style="text-align: left;" trbidi="on"><div class="separator" style="clear: both; text-align: left;"></div><pre style="text-align: -webkit-auto; white-space: pre-wrap; word-wrap: break-word;"><b>Background:  <br /></b><br />Whenever a piece of hardware, such as disk controller or ethernet card or mmc card, needs attention from the CPU, it throws an interrupt.  The interrupt tells<br />the CPU that something has happened and that the CPU should drop what<br />it's doing to handle the event.  In order to prevent mutliple devices from<br />sending the same interrupts, the IRQ system was established where each device<br />in a computer system is assigned its own special IRQ so that its interrupts<br />are unique.<br /><br />Starting with the 2.4 kernel, Linux has gained the ability to assign certain<br />IRQs to specific processors (or groups of processors).  This is known<br />as SMP IRQ affinity, and it allows you control how your system will respond<br />to various hardware events.  It allows you to restrict or repartition<br />the work load that you server must do so that it can more efficiently do<br />it's job.<br /><br />Obviously, in order for this to work, you will need a system that has more<br />than one processor (SMP).  You will also need to be running a 2.4 or higher<br />kernel.<br /><br />Some brief and very bare information on SMP IRQ affinity is provided in<br />the kernel source tree of the 2.4 kernel in the file:<br /><br /><b>    /usr/src/linux-2.4/Documentation/IRQ-affinity.txt<br /></b><br /><br /><b>How to use it:<br /></b><br />SMP affinity is controlled by manipulating files in the /proc/irq/ directory.<br />In /proc/irq/ are directories that correspond to the IRQs present on your<br />system (not all IRQs may be available). In each of these directories is<br />the "smp_affinity" file, and this is where we will work our magic.<br /><br />The first order of business is to figure out what IRQ a device is using.<br />This information is available in the /proc/interrupts file.  Here's a sample:<br /><br /><b> [root@archimedes /proc]# cat /proc/interrupts <br /></b>            CPU0       CPU1       CPU2       CPU3       <br />   0:    4865302    5084964    4917705    5017077    IO-APIC-edge  timer<br />   1:        132        108        159        113    IO-APIC-edge  keyboard<br />   2:          0          0          0          0          XT-PIC  cascade<br />   8:          0          1          0          0    IO-APIC-edge  rtc<br />  10:          0          0          0          0   IO-APIC-level  usb-ohci<br />  14:          0          0          1          1    IO-APIC-edge  ide0<br />  24:      87298      86066      86012      86626   IO-APIC-level  aic7xxx<br />  31:      93707     106211     107988      93329   IO-APIC-level  eth0<br /> NMI:          0          0          0          0 <br /> LOC:   19883500   19883555   19883441   19883424 <br /> ERR:          0<br /> MIS:          0<br /><br /><br />As you can see, this is a 4 processor machine.  The first column (unlabelled)<br />lists the IRQs used on the system.  The rows with letters (ie, "NMI", "LOC")<br />are parts of other drivers used on the system and aren't really accessible<br />to us, so we'll just ignore them.<br /><br />The second through fifth columns (labelled CPU0-CPU3) show the number of times<br />the corresponding process has handled an interrupt from that particular IRQ.<br />For example, all of the CPUs have handled roughly the same number of interrupts<br />for IRQ 24 (around 86,000 with CPU0 handling a little over 87,000).<br /><br />The sixth column lists whether or not the device driver associated with the <br />interrupt supports IO-APIC (see /usr/src/linux/Documentation/i386/IO-APIC.txt<br />for more information).  The only reason to look at this value is that <br />SMP affinity will only work for IO-APIC enabled device drivers.  For<br />example, we will not be able to change the affinity for the "cascade"<br />driver (IRQ 2) because it doesn't support IO-APIC.<br /><br />Finally, the seventh and last column lists the driver or device that is <br />associated with the interrupt.  In the above example, our ethernet card<br />(eth0) is using IRQ 31, and our SCSI controller (aic7xxx) is using IRQ 24.<br /><br />The first and last columns are really the only ones we're interested in here.<br />For the rest of this example, I'm going to assume that we want to adjust<br />the SMP affinity for th SCSI controller (IRQ 24).<br /><br />Now that we've got the IRQ, we can change the processor affinity.  To<br />do this, we'll go into the /proc/irq/24/ directory, and see what the<br />affinity is currently set to:<br /><br /><b> [root@archimedes Documentation]# cat /proc/irq/24/smp_affinity <br /></b> ffffffff<br /><br />This is a bitmask that represents which processors any interrupts on IRQ<br />24 should be routed to.  Each field in the bit mask corresponds to a processor.<br />The number held in the "smp_affinity" file is presented in hexadecimal format,<br />so in order to manipulate it properly we will need to convert our bit patterns<br />from binary to hex before setting them in the proc file.<br /><br />Each of the "f"s above represents a group of 4 CPUs, with the rightmost<br />group being the least significant.  For the purposes of our discussion,<br />we're going to limit ourselves to only the first 4 CPUs (although we can<br />address up to 32).<br /><br />In short, this means you only have to worry about the rightmost "f" and you<br />can assume everything else is a "0" (ie, our bitmask is "0000000f").<br /><br />"f" is the hexadecimal represenatation for the decimal number 15 (fifteen)<br />and the binary pattern of "1111".  Each of the places in the binary pattern<br />corresponds to a CPU in the server, which means we can use the following<br />chart to represent the CPU bit patterns:<br /><br />            Binary       Hex <br />    CPU 0    0001         1 <br />    CPU 1    0010         2<br />    CPU 2    0100         4<br />    CPU 3    1000         8<br /><br />By combining these bit patterns (basically, just adding the Hex values), we<br />can address more than one processor at a time.   For example, if I wanted<br />to talk to both CPU0 and CPU2 at the same time, the result is:<br /><br />            Binary       Hex <br />    CPU 0    0001         1 <br />  + CPU 2    0100         4<br />    -----------------------<br />    both     0101         5<br /><br />If I want to address all four of the processors at once, then the result is:<br /><br />            Binary       Hex <br />    CPU 0    0001         1 <br />    CPU 1    0010         2<br />    CPU 2    0100         4<br />  + CPU 3    1000         8<br />    -----------------------<br />    both     1111         f<br /><br />(Remember that we use the letters "a" through "f" to represent the numbers<br /> "10" to "15" in hex notation).<br /><br />Given that, we now know that if we have a four processor system, we can <br />assign any of 15 different CPU combinations to an IRQ (it would be 16, but<br />it isn't legal to assign an IRQ affinity of "0" to any IRQ... if you try,<br />Linux will just ignore your attempt).<br /><br />So.  Now we get to the fun part.  Remember in our /proc/interrupts listing<br />above that all four of our CPUs had handled the close to the same amount of<br />interrupts for our SCSI card?  We now have the tools needed to limit managing<br />the SCSI card to just one processor and leave the other three free to<br />concentrate on doing other tasks.   Let's assume that we want to dedicate<br />our first CPU (CPU0) to handling the SCSI controller interrupts.  To do this,<br />we would simply run the following command:<br /><br /><b> [root@archimedes /proc]# echo 1 &gt; /proc/irq/24/smp_affinity <br /> [root@archimedes /proc]# cat /proc/irq/24/smp_affinity <br /></b> 00000001<br /><br />Now, let's test it out and see what happens:<br /><br /> [root@archimedes /proc]# cd /tmp/<br /> [root@archimedes /tmp]# tar -zcf test.tgz /usr/src/linux-2.4.2 <br /> tar: Removing leading `/' from member names<br /> [root@archimedes /tmp]# tar -zxf test.tgz &amp;&amp; rm -rf usr/<br /> [root@archimedes /tmp]# tar -zxf test.tgz &amp;&amp; rm -rf usr/<br /> [root@archimedes /tmp]# tar -zxf test.tgz &amp;&amp; rm -rf usr/<br /> [root@archimedes /tmp]# tar -zxf test.tgz &amp;&amp; rm -rf usr/<br /> [root@archimedes /tmp]# tar -zxf test.tgz &amp;&amp; rm -rf usr/<br /> [root@archimedes /tmp]# cat /proc/interrupts | grep 24:<br />  24:      99719      86067      86012      86627   IO-APIC-level  aic7xxx<br /><br />Compare that to the previous run without having the IRQ bound to CPU0:<br /><br />  24:      87298      86066      86012      86626   IO-APIC-level  aic7xxx<br /><br />All of the interrupts from the disk controller are now handled exclusively<br />by the first CPU (CPU0), which means that our other 3 proccessors are free<br />to do other stuff now.<br /><br />Finally, it should be pointed out that if you decide you no longer want<br />SMP affinity and would rather have the system revert back to the old set up,<br />then you can simply do:<br /><br /><b> [root@archimedes /tmp]# cat /proc/irq/prof_cpu_mask &gt;/proc/irq/24/smp_affinity<br /></b><br />This will reset the "smp_affinity" file to use all "f"s, and will return to<br />the load sharing arrangement that we saw earlier.<br /><br /><br /><b>What can I use it for?<br /></b><br />- "balance" out multiple NICs in a multi-processor machine.  By tying a single<br />  NIC to a single CPU, you should be able to scale the amount of traffic<br />  your server can handle nicely.<br /><br />- database servers (or servers with lots of disk storage) that also have<br />  heavy network loads can dedicate a CPU to their disk controller and assign<br />  another to deal with the NIC to help improve response times.<br /><br /><br /><b>Can I do this with processes?<br /></b><br />At this time, no.</pre><pre style="text-align: -webkit-auto; white-space: pre-wrap; word-wrap: break-word;"><br /></pre><pre style="text-align: -webkit-auto; white-space: pre-wrap; word-wrap: break-word;"><b>Example: Changing SMP IRQ Affinity of mmc0 card<br /><br /></b></pre><div class="separator" style="clear: both; text-align: center;"><a href="http://2.bp.blogspot.com/-lRqUzMgU2iM/USk5xmdiauI/AAAAAAAAAM4/R-Rnzdjw25Y/s1600/Screenshot-1.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="400" src="http://2.bp.blogspot.com/-lRqUzMgU2iM/USk5xmdiauI/AAAAAAAAAM4/R-Rnzdjw25Y/s640/Screenshot-1.png" width="640" /></a></div><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://1.bp.blogspot.com/-2g714FAbzLo/USk5xz8xLcI/AAAAAAAAAM8/NS5AnTSk50w/s1600/Screenshot-2.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="400" src="http://1.bp.blogspot.com/-2g714FAbzLo/USk5xz8xLcI/AAAAAAAAAM8/NS5AnTSk50w/s640/Screenshot-2.png" width="640" /></a></div><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://2.bp.blogspot.com/-krJ6YMHEDA4/USk5xoE_XCI/AAAAAAAAANA/Z4Pyy254xKc/s1600/Screenshot-3.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="400" src="http://2.bp.blogspot.com/-krJ6YMHEDA4/USk5xoE_XCI/AAAAAAAAANA/Z4Pyy254xKc/s640/Screenshot-3.png" width="640" /></a></div><br /></div>