---
layout: post
title: MTD devices
date: '2014-03-27T20:57:00.001+05:00'
author: Abbas Raza
tags: 
modified_time: '2014-03-27T20:57:11.120+05:00'
blogger_id: tag:blogger.com,1999:blog-3367966882409306161.post-785386941777333931
blogger_orig_url: https://abbas-raza.blogspot.com/2014/03/mtd-devices.html
---

<div dir="ltr" style="text-align: left;" trbidi="on"><br /><div class="hentry-meta">        <h1>Working with MTD Devices</h1><div class="hentry-meta-data">By <a href="http://www.linuxforu.com/author/mohan-lal-jangir/" rel="author" title="Posts by Mohan Lal Jangir">Mohan Lal Jangir</a> on January 31, 2012 in <a href="http://www.linuxforu.com/category/coding/" rel="category tag" title="View all posts in Coding">Coding</a>, <a href="http://www.linuxforu.com/category/developers/" rel="category tag" title="View all posts in Developers">Developers</a> · <a data-disqus-identifier="9415 http://www.linuxforu.com/?p=9415" href="http://www.linuxforu.com/2012/01/working-with-mtd-devices/#disqus_thread" title="Comment on Working with MTD Devices">6 Comments</a></div></div><div class="hentry-container clear">                <div class="hentry-middle">            <div class="hentry-content clear">                <img alt="Memory Technology Devices" class="aligncenter size-large wp-image-9418" height="315" src="http://www.linuxforu.com/wp-content/uploads/2012/01/mtd-590x315.png" title="Memory Technology Devices" width="590" /><br /> <div class="introduction">This article shows how kernel and application developers (in C) can make use of MTD in Linux.</div>MTD (Memory Technology Devices) are NAND/NOR-based flash memory chips  used for storing non-volatile data like boot images and configurations.  Readers are cautioned not to get confused with USB sticks, SD cards,  etc., which are also called flash devices, but are not MTD devices. The  latter are generally found on development boards, used to store boot  loaders, an OS, etc.<br /> Even though MTD devices are for data storage, they differ from hard  disks and RAM in several aspects. The biggest difference is that while  hard disk sectors are rewritable, MTD device sectors must be erased  before rewriting — which is why they are more commonly called  erase-blocks. Second, hard disk sectors can be rewritten several times  without wearing out the hardware, but MTD device sectors have a limited  life and are not usable after about 10^3-10^5 erase operations. The worn  out erase-blocks are called bad blocks and the software must take care  not to use such blocks.<br /> Like hard disks, MTD devices can be partitioned and can therefore act  as independent devices. On a system with one or more MTD devices,  device and partition information can be obtained from the <code>/proc/mtd</code> file. A typical <code>/proc/mtd</code> file is as follows:<br /> <div><div class="syntaxhighlighter nogutter notranslate text" id="highlighter_798013"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="text plain">cat /proc/mtd </code></div><div class="line number2 index1 alt1"><code class="text plain">dev:&nbsp; size&nbsp;&nbsp;&nbsp; erasesize name </code></div><div class="line number3 index2 alt2"><code class="text plain">mtd0: 000a0000 00020000 "misc" </code></div><div class="line number4 index3 alt1"><code class="text plain">mtd1: 00420000 00020000 "recovery" </code></div><div class="line number5 index4 alt2"><code class="text plain">mtd2: 002c0000 00020000 "boot" </code></div><div class="line number6 index5 alt1"><code class="text plain">mtd3: 0fa00000 00020000 "system" </code></div><div class="line number7 index6 alt2"><code class="text plain">mtd4: 02800000 00020000 "cache" </code></div><div class="line number8 index7 alt1"><code class="text plain">mtd5: 0af20000 00020000 "userdata"</code></div></div></td></tr></tbody></table></div></div>A partitioned MTD device can be depicted as in Figure 1, which shows  the relation between an MTD device, a partition and a sector.<br /> <div class="wp-caption aligncenter" id="attachment_9416" style="width: 450px;"><img alt="An MTD device" class="size-full wp-image-9416" height="477" src="http://www.linuxforu.com/wp-content/uploads/2012/01/figure-1-an-MTD-Device.jpg" title="An MTD device" width="450" /><div class="wp-caption-text">Figure 1: An MTD device</div></div>As already said, MTD write operations are different from usual storage  devices. Therefore, before we move further, let’s understand how write  operations take place on MTD devices. Figure 2 shows a typical write  case.<br /> <div class="wp-caption aligncenter" id="attachment_9417" style="width: 590px;"><img alt="An MTD write operation" class="size-large wp-image-9417" height="172" src="http://www.linuxforu.com/wp-content/uploads/2012/01/figure-2-590x172.jpg" title="An MTD write operation" width="590" /><div class="wp-caption-text">Figure 2: An MTD write operation</div></div>The left-most part shows a sector that has some data at the end. The  rest of the sector has not been written since the last erase. A user  wants to write “new data 1″ to this sector at offset 0. Since this part  of the sector has already been erased, it is ready to be written and so  “new data 1″ can be directly written to the sector. Later, the user may  want to write “new data 2″, again at offset 0. To do this, the sector  must be erased. Since the sector needs to be erased in entirety, the  “old data” must be backed up in a temporary buffer. After erasing the  complete sector, the “new data 2″ and “old data” must be written at  appropriate offsets.<br /> This procedure is the reason there are specific file systems for MTD  devices, like JFFS2 and YAFFFS, and flash translation layers (FTL) like  NFTL, INFTL, etc. These FTLs and file systems take special care of MTD  device properties to hide complexity from the user.<br /> In the first section that follows, we will look at how to access,  read/write and erase MTD devices from Linux applications. The second  section describes the same things in kernel space, so that this article  can be useful to both application as well as kernel developers.<br /> <h2>Accessing MTDs from applications</h2>The user must know the device partition to work upon, which can be found from <code>/proc/mtd</code> as shown earlier. Assuming users want to work on the “userdata” partition, they must use the <code>/dev/mtd5</code> device.<br /> The first thing to do is to get information about the MTD device. Use the <code>MEMGETINFO ioctl</code> command, as follows:<br /> <div><div class="syntaxhighlighter notranslate c" id="highlighter_218640"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div><div class="line number4 index3 alt1">4</div><div class="line number5 index4 alt2">5</div><div class="line number6 index5 alt1">6</div><div class="line number7 index6 alt2">7</div><div class="line number8 index7 alt1">8</div><div class="line number9 index8 alt2">9</div><div class="line number10 index9 alt1">10</div><div class="line number11 index10 alt2">11</div><div class="line number12 index11 alt1">12</div><div class="line number13 index12 alt2">13</div><div class="line number14 index13 alt1">14</div><div class="line number15 index14 alt2">15</div><div class="line number16 index15 alt1">16</div><div class="line number17 index16 alt2">17</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="c preprocessor">#include <stdio .h=""></stdio></code></div><div class="line number2 index1 alt1"><code class="c preprocessor">#include <fcntl .h=""></fcntl></code></div><div class="line number3 index2 alt2"><code class="c preprocessor">#include <sys ioctl.h=""></sys></code></div><div class="line number4 index3 alt1"><code class="c preprocessor">#include <mtd mtd-user.h=""></mtd></code></div><div class="line number5 index4 alt2">&nbsp;</div><div class="line number6 index5 alt1"><code class="c color1 bold">int</code> <code class="c plain">main()</code></div><div class="line number7 index6 alt2"><code class="c plain">{</code></div><div class="line number8 index7 alt1"><code class="c spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="c plain">mtd_info_t mtd_info;</code></div><div class="line number9 index8 alt2"><code class="c spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="c color1 bold">int</code> <code class="c plain">fd = open(</code><code class="c string">"/dev/mtd5"</code><code class="c plain">, O_RDWR);</code></div><div class="line number10 index9 alt1"><code class="c plain">ioctl(fd, MEMGETINFO, &amp;mtd_info);</code></div><div class="line number11 index10 alt2">&nbsp;</div><div class="line number12 index11 alt1"><code class="c spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="c functions bold">printf</code><code class="c plain">(</code><code class="c string">"MTD type: %u\n"</code><code class="c plain">, mtd_info.type);</code></div><div class="line number13 index12 alt2"><code class="c spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="c functions bold">printf</code><code class="c plain">(</code><code class="c string">"MTD total size : %u bytes\n"</code><code class="c plain">, mtd_info.size);</code></div><div class="line number14 index13 alt1"><code class="c spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="c functions bold">printf</code><code class="c plain">(</code><code class="c string">"MTD erase size : %u bytes\n"</code><code class="c plain">, mtd_info.erasesize);</code></div><div class="line number15 index14 alt2">&nbsp;</div><div class="line number16 index15 alt1"><code class="c spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="c keyword bold">return</code> <code class="c plain">0;</code></div><div class="line number17 index16 alt2"><code class="c plain">}</code></div></div></td></tr></tbody></table></div></div>Error handling has been omitted for brevity. The <code>mtd_info_t</code> structure is used with the <code>MEMGETINFO</code> command. The MTD type can be <code>MTD_ABSENT</code>, <code>MTD_RAM</code>, <code>MTD_ROM</code>, <code>MTD_NAND</code>, <code>MTD_NOR</code>, etc., which are defined in the <code>mtd/mtd-abi.h</code> header file. The <code>mtd_info.size</code> indicates the size of the whole device (i.e., the partition, in this case). Finally, <code>mtd_info.erasesize</code> indicates the sector size. During an erase operation, this is the minimum size that can be erased, as we’ll see later.<br /> Reading MTD devices is similar to ordinary devices:<br /> <div><div class="syntaxhighlighter nogutter notranslate c" id="highlighter_111734"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="c comments">/* read something from last sector */</code></div><div class="line number2 index1 alt1"><code class="c plain">unsigned </code><code class="c color1 bold">char</code> <code class="c plain">buf[64];</code></div><div class="line number3 index2 alt2"><code class="c plain">lseek(fd, -mtd_info.erasesize, SEEK_END);</code></div><div class="line number4 index3 alt1"><code class="c plain">read(fd, buf, </code><code class="c keyword bold">sizeof</code><code class="c plain">(buf));</code></div></div></td></tr></tbody></table></div></div>A write operation can be performed in the same way, provided the  sector has been erased previously. Finally, we come to the erase  operation. Here is an example of erasing a partition, sector by sector:<br /> <div><div class="syntaxhighlighter nogutter notranslate c" id="highlighter_186965"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="c keyword bold">void</code> <code class="c plain">erase_partition(mtd_info_t *mtd_info, </code><code class="c color1 bold">int</code> <code class="c plain">fd) {</code></div><div class="line number2 index1 alt1"><code class="c spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="c plain">erase_info_t ei;</code></div><div class="line number3 index2 alt2"><code class="c spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="c plain">ei.length = mtd_info-&gt;erasesize;</code></div><div class="line number4 index3 alt1"><code class="c spaces">&nbsp;</code>&nbsp;</div><div class="line number5 index4 alt2"><code class="c spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="c keyword bold">for</code><code class="c plain">(ei.start = 0; ei.start &lt; mtd_info-&gt;size; ei.start += mtd_info-&gt;erasesize) {</code></div><div class="line number6 index5 alt1"><code class="c spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;</code><code class="c plain">ioctl(fd, MEMUNLOCK, &amp;ei);</code></div><div class="line number7 index6 alt2"><code class="c spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;</code><code class="c plain">ioctl(fd, MEMERASE, &amp;ei);</code></div><div class="line number8 index7 alt1"><code class="c spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="c plain">}</code></div><div class="line number9 index8 alt2"><code class="c plain">}</code></div></div></td></tr></tbody></table></div></div>All sectors of the device are writeable after this erase operation. Notice the use of <code>MEMUNLOCK</code> before <code>MEMERASE</code>, which is essential to allow the erase operation.<br /> <h2>Accessing MTDs from kernel space</h2>This section will repeat the functions explained in the previous  section, but in kernel space. This needs a separate section since the  erase operation is more complex here&nbsp; –&nbsp; the erase operation may sleep  and therefore the kernel programmer has to wait until the operation is  completed. This is the case for applications too, but the sleep is  transparently taken care of by the scheduler.<br /> As explained earlier, the first MTD information is the <code>mtd_info</code> structure. This is retrieved by iterating through all registered MTD devices:<br /> <div><div class="syntaxhighlighter notranslate c" id="highlighter_172601"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="gutter"><div class="line number1 index0 alt2">1</div><div class="line number2 index1 alt1">2</div><div class="line number3 index2 alt2">3</div><div class="line number4 index3 alt1">4</div><div class="line number5 index4 alt2">5</div><div class="line number6 index5 alt1">6</div><div class="line number7 index6 alt2">7</div><div class="line number8 index7 alt1">8</div><div class="line number9 index8 alt2">9</div><div class="line number10 index9 alt1">10</div><div class="line number11 index10 alt2">11</div><div class="line number12 index11 alt1">12</div><div class="line number13 index12 alt2">13</div><div class="line number14 index13 alt1">14</div><div class="line number15 index14 alt2">15</div><div class="line number16 index15 alt1">16</div><div class="line number17 index16 alt2">17</div><div class="line number18 index17 alt1">18</div><div class="line number19 index18 alt2">19</div><div class="line number20 index19 alt1">20</div><div class="line number21 index20 alt2">21</div><div class="line number22 index21 alt1">22</div><div class="line number23 index22 alt2">23</div><div class="line number24 index23 alt1">24</div><div class="line number25 index24 alt2">25</div><div class="line number26 index25 alt1">26</div><div class="line number27 index26 alt2">27</div><div class="line number28 index27 alt1">28</div><div class="line number29 index28 alt2">29</div><div class="line number30 index29 alt1">30</div><div class="line number31 index30 alt2">31</div><div class="line number32 index31 alt1">32</div><div class="line number33 index32 alt2">33</div><div class="line number34 index33 alt1">34</div><div class="line number35 index34 alt2">35</div><div class="line number36 index35 alt1">36</div><div class="line number37 index36 alt2">37</div><div class="line number38 index37 alt1">38</div></td><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="c preprocessor">#include <linux kernel.h=""></linux></code></div><div class="line number2 index1 alt1"><code class="c preprocessor">#include <linux mtd.h="" mtd=""></linux></code></div><div class="line number3 index2 alt2"><code class="c preprocessor">#include <linux err.h=""></linux></code></div><div class="line number4 index3 alt1">&nbsp;</div><div class="line number5 index4 alt2"><code class="c keyword bold">static</code> <code class="c keyword bold">struct</code> <code class="c plain">mtd_info *mtd_info = NULL;</code></div><div class="line number6 index5 alt1"><code class="c spaces">&nbsp;</code>&nbsp;</div><div class="line number7 index6 alt2"><code class="c color1 bold">int</code> <code class="c plain">init_module(</code><code class="c keyword bold">void</code><code class="c plain">) {</code></div><div class="line number8 index7 alt1"><code class="c spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="c color1 bold">int</code> <code class="c plain">num;</code></div><div class="line number9 index8 alt2"><code class="c spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="c keyword bold">for</code><code class="c plain">(num = 0; num &lt; 64; num++) {</code></div><div class="line number10 index9 alt1"><code class="c spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;</code><code class="c plain">mtd_info = get_mtd_device(NULL, num);</code></div><div class="line number11 index10 alt2"><code class="c spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;</code><code class="c keyword bold">if</code><code class="c plain">(IS_ERR(mtd_info)) {</code></div><div class="line number12 index11 alt1"><code class="c spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;</code><code class="c plain">printk(</code><code class="c string">"No device for num %d\n"</code><code class="c plain">, num);</code></div><div class="line number13 index12 alt2"><code class="c spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;</code><code class="c keyword bold">continue</code><code class="c plain">;</code></div><div class="line number14 index13 alt1"><code class="c spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;</code><code class="c plain">}</code></div><div class="line number15 index14 alt2"><code class="c spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;</code><code class="c keyword bold">if</code><code class="c plain">(mtd_info-&gt;type == MTD_ABSENT) {</code></div><div class="line number16 index15 alt1"><code class="c spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;</code><code class="c plain">put_mtd_device(mtd_info);</code></div><div class="line number17 index16 alt2"><code class="c spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;</code><code class="c keyword bold">continue</code><code class="c plain">;</code></div><div class="line number18 index17 alt1"><code class="c spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;</code><code class="c plain">}</code></div><div class="line number19 index18 alt2"><code class="c spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;</code><code class="c keyword bold">if</code><code class="c plain">(</code><code class="c functions bold">strcmp</code><code class="c plain">(mtd_info-&gt;name, </code><code class="c string">"userdata"</code><code class="c plain">)) {</code></div><div class="line number20 index19 alt1"><code class="c spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;</code><code class="c plain">put_mtd_device(mtd_info);</code></div><div class="line number21 index20 alt2"><code class="c spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;</code><code class="c keyword bold">continue</code><code class="c plain">;</code></div><div class="line number22 index21 alt1"><code class="c spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;</code><code class="c plain">}</code></div><div class="line number23 index22 alt2"><code class="c spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;</code><code class="c plain">printk(</code><code class="c string">"MTD type: %u\n"</code><code class="c plain">, mtd_info-&gt;type);</code></div><div class="line number24 index23 alt1"><code class="c spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;</code><code class="c plain">printk(</code><code class="c string">"MTD total size : %u bytes\n"</code><code class="c plain">, mtd_info-&gt;size);</code></div><div class="line number25 index24 alt2"><code class="c spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;</code><code class="c plain">printk(</code><code class="c string">"MTD erase size : %u bytes\n"</code><code class="c plain">, mtd_info-&gt;erasesize);</code></div><div class="line number26 index25 alt1"><code class="c spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;</code><code class="c keyword bold">return</code> <code class="c plain">0;</code></div><div class="line number27 index26 alt2"><code class="c spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="c plain">}</code></div><div class="line number28 index27 alt1"><code class="c spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="c plain">mtd_info = NULL;</code></div><div class="line number29 index28 alt2"><code class="c spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="c keyword bold">return</code> <code class="c plain">0;</code></div><div class="line number30 index29 alt1"><code class="c plain">}</code></div><div class="line number31 index30 alt2"><code class="c spaces">&nbsp;</code>&nbsp;</div><div class="line number32 index31 alt1"><code class="c keyword bold">void</code> <code class="c plain">cleanup_module(</code><code class="c keyword bold">void</code><code class="c plain">)</code></div><div class="line number33 index32 alt2">&nbsp;</div><div class="line number34 index33 alt1"><code class="c plain">{</code></div><div class="line number35 index34 alt2">&nbsp;</div><div class="line number36 index35 alt1"><code class="c keyword bold">if</code><code class="c plain">(mtd_info)</code></div><div class="line number37 index36 alt2"><code class="c spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;</code><code class="c plain">put_mtd_device(mtd_info);</code></div><div class="line number38 index37 alt1"><code class="c plain">}</code></div></div></td></tr></tbody></table></div></div>The above kernel module searches for the “userdata” partition. The function <code>get_mtd_device()</code>, when invoked with the first argument <code>NULL</code>,  returns the MTD device associated with the minor number specified in  the second argument. On a successful search, it increments the reference  count of the device. That’s why, before exiting, a call to <code>put_mtd_device()</code> must be made to release (decrement) the reference count.<br /> Additionally, the module uses the <code>flag MTD_ABSENT</code> (which  is available to applications too). This check is required to function  correctly with some probing device drivers used to allocate placeholder  MTD devices on systems that have socketed or removable media.<br /> Having retrieved the <code>mtd_info</code> structure, reading is relatively simple:<br /> <div><div class="syntaxhighlighter nogutter notranslate c" id="highlighter_738159"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="c comments">/* read something from last sector */</code></div><div class="line number2 index1 alt1"><code class="c plain">u_char buf[64];</code></div><div class="line number3 index2 alt2">&nbsp;</div><div class="line number4 index3 alt1"><code class="c plain">mtd_info-&gt;read(mtd_info, mtd_info.size-mtd_info.erasesize, </code><code class="c keyword bold">sizeof</code><code class="c plain">(buf), buf);</code></div></div></td></tr></tbody></table></div></div>The second argument of the read function specifies the read offset,  and the third the length to read. Note that the read operation too may  sleep and, therefore, it must not be performed in an interrupt context.  The write operation can be performed as follows (assuming the sector has  been previously erased):<br /> <div><div class="syntaxhighlighter nogutter notranslate c" id="highlighter_229623"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="c comments">/* write something to last sector */</code></div><div class="line number2 index1 alt1"><code class="c plain">mtd_info-&gt;write(mtd_info, mtd_info.size-mtd_info.erasesize, </code><code class="c keyword bold">sizeof</code><code class="c plain">(buf), buf);</code></div></div></td></tr></tbody></table></div></div>As mentioned before, the read, write and erase operations may sleep.  Therefore, kernel code must wait for the operation to finish. Here is an  example of erasing the partition and waiting to finish the operation:<br /> <div><div class="syntaxhighlighter nogutter notranslate c" id="highlighter_399849"><table border="0" cellpadding="0" cellspacing="0"><tbody><tr><td class="code"><div class="container"><div class="line number1 index0 alt2"><code class="c preprocessor">#include <linux sched.h=""></linux></code></div><div class="line number2 index1 alt1">&nbsp;</div><div class="line number3 index2 alt2"><code class="c keyword bold">void</code> <code class="c plain">erase_partition(</code><code class="c keyword bold">struct</code> <code class="c plain">mtd_info *mtd_info) {</code></div><div class="line number4 index3 alt1"><code class="c spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="c plain">unsigned </code><code class="c color1 bold">int</code> <code class="c plain">start;</code></div><div class="line number5 index4 alt2"><code class="c spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="c keyword bold">for</code><code class="c plain">(start = 0; start &lt; mtd_info-&gt;size; start += mtd_info-&gt;erasesize) </code></div><div class="line number6 index5 alt1"><code class="c spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;</code><code class="c plain">erase_sector(mtd_info, start, mtd_info-&gt;erasesize);</code></div><div class="line number7 index6 alt2"><code class="c plain">}</code></div><div class="line number8 index7 alt1"><code class="c spaces">&nbsp;</code>&nbsp;</div><div class="line number9 index8 alt2"><code class="c keyword bold">void</code> <code class="c plain">erase_sector(</code><code class="c keyword bold">struct</code> <code class="c plain">mtd_info *mtd_info, unsigned </code><code class="c color1 bold">int</code> <code class="c plain">start, unsigned </code><code class="c color1 bold">int</code> <code class="c plain">len) </code></div><div class="line number10 index9 alt1">&nbsp;</div><div class="line number11 index10 alt2"><code class="c plain">{</code></div><div class="line number12 index11 alt1"><code class="c spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="c color1 bold">int</code> <code class="c plain">ret;</code></div><div class="line number13 index12 alt2"><code class="c spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="c keyword bold">struct</code> <code class="c plain">erase_info ei = {0};</code></div><div class="line number14 index13 alt1"><code class="c spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="c plain">wait_queue_head_t waitq;</code></div><div class="line number15 index14 alt2"><code class="c spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="c plain">DECLARE_WAITQUEUE(wait, current);</code></div><div class="line number16 index15 alt1"><code class="c spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code>&nbsp;</div><div class="line number17 index16 alt2"><code class="c spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="c plain">init_waitqueue_head(&amp;waitq);</code></div><div class="line number18 index17 alt1"><code class="c spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="c plain">ei.addr = start;</code></div><div class="line number19 index18 alt2"><code class="c spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="c plain">ei.len = mtd_info-&gt;erasesize;</code></div><div class="line number20 index19 alt1"><code class="c spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="c plain">ei.mtd = mtd_info;</code></div><div class="line number21 index20 alt2"><code class="c spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="c plain">ei.callback = erase_callback;</code></div><div class="line number22 index21 alt1"><code class="c spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="c plain">ei.priv = (unsigned </code><code class="c color1 bold">long</code><code class="c plain">)&amp;waitq;</code></div><div class="line number23 index22 alt2"><code class="c spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="c plain">ret = mtd_info-&gt;erase(mtd_info, &amp;ei);</code></div><div class="line number24 index23 alt1"><code class="c spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="c keyword bold">if</code><code class="c plain">(!ret) &nbsp;&nbsp; &nbsp;{</code></div><div class="line number25 index24 alt2"><code class="c spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;</code><code class="c plain">set_current_state(TASK_UNINTERRUPTIBLE);</code></div><div class="line number26 index25 alt1"><code class="c spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;</code><code class="c plain">add_wait_queue(&amp;waitq, &amp;wait);</code></div><div class="line number27 index26 alt2"><code class="c spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;</code><code class="c keyword bold">if</code> <code class="c plain">(ei.state != MTD_ERASE_DONE &amp;&amp; ei.state != MTD_ERASE_FAILED)</code></div><div class="line number28 index27 alt1"><code class="c spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;</code><code class="c plain">schedule();</code></div><div class="line number29 index28 alt2"><code class="c spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;</code><code class="c plain">remove_wait_queue(&amp;waitq, &amp;wait);</code></div><div class="line number30 index29 alt1"><code class="c spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;</code><code class="c plain">set_current_state(TASK_RUNNING);</code></div><div class="line number31 index30 alt2"><code class="c spaces">&nbsp;</code>&nbsp;</div><div class="line number32 index31 alt1"><code class="c spaces">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;</code><code class="c plain">ret = (ei.state == MTD_ERASE_FAILED)?-EIO:0;</code></div><div class="line number33 index32 alt2"><code class="c spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="c plain">}</code></div><div class="line number34 index33 alt1"><code class="c plain">}</code></div><div class="line number35 index34 alt2"><code class="c spaces">&nbsp;</code>&nbsp;</div><div class="line number36 index35 alt1"><code class="c keyword bold">void</code> <code class="c plain">erase_callback (</code><code class="c keyword bold">struct</code> <code class="c plain">erase_info *instr) {</code></div><div class="line number37 index36 alt2"><code class="c spaces">&nbsp;&nbsp;&nbsp;&nbsp;</code><code class="c plain">wake_up((wait_queue_head_t *)instr-&gt;priv);</code></div><div class="line number38 index37 alt1"><code class="c plain">}</code></div></div></td></tr></tbody></table></div></div>The <code>erase_partition()</code> function iterates over all sectors, and erases them with <code>erase_sector()</code>. At the core of <code>erase_sector()</code> is the <code>mtd_info-&gt;erase</code> call, which (as mentioned previously) may sleep. Therefore, <code>erase_sector()</code> prepares a wait queue and a wait queue head. <br /> After a call to <code>mtd_info-&gt;erase</code>, the function prepares itself to relinquish the CPU (presuming that <code>mtd_info-&gt;erase</code> will sleep) by changing task state to <code>TASK_UNINTERRUPTIBLE</code> and adding itself to the wait queue head. Before relinquishing the CPU, it checks if erase is done, through the <code>ei.state</code> flag. If erase is done successfully, this flag will be set to <code>MTD_ERASE_DONE</code>.<br /> If the erase operation is not complete, the task relinquishes the CPU by calling <code>schedule()</code>. Later, when the erase operation is complete, the driver calls the callback function provided in <code>ei.callback</code>. Here the task wakes up to itself, then removes itself from the wait queue, changes the task state to <code>TASK_RUNNING</code> and finally, the <code>erase_sector()</code> function returns.<br /> MTD devices have many more features that can be used by application  programmers. ECC (error correction codes) and OOB (out of band) data are  some of them. The MTD framework is integrated into the Linux kernel —  therefore it makes working with MTD devices very simple, as we have seen  in this article.</div></div></div></div>