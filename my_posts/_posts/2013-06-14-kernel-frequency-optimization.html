---
layout: post
title: Kernel frequency optimization
date: '2013-06-14T03:00:00.001+05:00'
author: Abbas Raza
tags: 
modified_time: '2013-06-20T01:20:44.795+05:00'
thumbnail: http://3.bp.blogspot.com/-6PRLvxP4Kqc/UbpBRFShNpI/AAAAAAAAAXc/ss8PEQOwD74/s72-c/config_hz-im.jpg
blogger_id: tag:blogger.com,1999:blog-3367966882409306161.post-5947833919170939264
blogger_orig_url: https://abbas-raza.blogspot.com/2013/06/kernel-frequency-optimization.html
---

<div dir="ltr" style="text-align: left;" trbidi="on"><br /><br /><br /><header class="entry-header">  <h1 class="entry-title">Kernel frequency optimization – just another reason to not to use stock kernel</h1><div class="entry-meta"><span class="sep">Posted on </span><a href="http://314.tt/blog/kernel-frequency-optimization-just-another-reason-to-not-to-use-stock-kernel/05-09-2010/" rel="bookmark" title="11:36 pm"><time class="entry-date" datetime="2010-09-05T23:36:37+00:00" pubdate="">September 5, 2010</time></a><span class="by-author"> <span class="sep"> by </span> <span class="author vcard"><a class="url fn n" href="http://314.tt/blog/author/wojtek/" rel="author" title="View all posts by Wojtek Ziniewicz">Wojtek Ziniewicz</a></span></span>  </div></header>  <br /><div class="entry-content"><br />Nowadays  ,especially during and even after the time of economic crisis,  sysadmins are dealing with one big problem that is usually defined by  their business managers -<em> “How to squeeze more and more computing power from server farm “</em>. As during the “<a href="http://en.wikipedia.org/wiki/Dot-com_bubble" target="_blank">.com era</a>”  big hardware players were generally rushing towards 1 faster and faster  CPU as well as larger amount of RAM. But now that we have multi-cpu  servers which demand more and more power, we pack more cores into one  central processing unit and build faster <a href="http://en.wikipedia.org/wiki/Solid-state_drive" target="_blank">SSD hard drives</a>,  we also build multi-server farms that allow us to get more computing  power that ever imagined. But what is the outcome of this process ?<br /><ul><li>In order to control the environment ,we developed automation tools for extremely large datacenters . <a href="http://www.puppetlabs.com/" target="_blank">Puppet</a> is very good example,</li><li> We developed high level load balancers like <a href="http://haproxy.1wt.eu/" target="_blank">HAproxy</a> or Linux <a href="http://www.linuxvirtualserver.org/" target="_blank">Virtual Server</a> that guarantee coherency and scalability of our server farms,</li><li> We learned how to synchronize geographically dispersed datacenters with complex <a href="http://en.wikipedia.org/wiki/Clustered_file_system" target="_blank">clustered filesystems</a> that run gently over tcp/ip stack,</li><li> Long time ago we observed that it is generally good idea to avoid very expensive <a href="http://en.wikipedia.org/wiki/Context_switch" target="_blank">context switches</a>, so we decided to use hardware-partitioning so different types of IO reside on separate boxes,</li><li> We started to separate even so high-level applications like memory buffer stores (<a href="http://memcached.org/" target="_blank">memcached</a>) and data storage nodes (<a href="http://forge.mysql.com/wiki/NDB" target="_blank">mysql ndb</a>) or implement query-partitioning so our databases work faster and faster,</li><li>As system <a href="http://en.wikipedia.org/wiki/Bottleneck" target="_blank">bottlenecks</a> appear, we learned how to wisely choose hardware so there’s no chance they occur.</li></ul>We may continue building this list, but taking into account the  general hardware-driven development of sys-utils that are the daily  bread of every sysadmin life, we totally forgot about very powerful  tools that reside inside the linux kernel. So, usually when bottlenecks  appear, we act after the problem occurs. How about being more proactive ?<br />Generally when we are lacking computing power, we add more servers to  the rack and everybody’s happy. But what can we do when adding more  servers is not an option ? Optimizing applications code ? Rearranging  system services and building the system layout from scratch ? Finally –  telling our customer that <strong>we can’t bear more load</strong>. This  is of course not possible . Let’s try to look inside the kernel and see  what can we squeeze out of it on the very simple example on one  instance of <a href="http://www.cherokee-project.com/">Cherokee www server</a> . Everything fulfills one assumption – let it be simple and less time consuming than building our server-farm from scratch.<br />Research will be done by benchmarking static content throughput via cherokee webserver on <a href="http://www.debian.org/releases/testing/" target="_blank">Debian Squeeze</a> with various kernel configuration using apache benchmark (<a href="http://httpd.apache.org/docs/2.0/programs/ab.html" target="_blank">ab</a>) that is generally the best and simplest tool for measuring performance of any http application.<br />We will be tampering with <a href="http://kerneltrap.org/node/464" target="_self">CONFIG_HZ</a> option in kernel. But to fully understand the optimization, we have to  understand what is “Timer frequency” and HZ setting in kernel:<br /><blockquote>HZ is the frequency with which the system’s timer  hardware is programmed to interrupt the kernel . Much of the kernel’s  internal housekeeping, including process accounting, scheduler time  slice accounting, and internal time management, is done in the timer  interrupt handler. Thus, the frequency of the timer interrupt affects a  number of things; in particular, it puts an upper bound on the  resolution of timers used with the kernel. If HZ is 1000 (the i386  default for 2.6 kernels through 2.6.12), then timers will have a  best-case resolution of 1ms. If, instead, HZ is 100 (the 2.4 and prior  default), that resolution is 10ms. In the other words – setting right HZ  will tell our system how frequent it should wake up and see if there’s  something to do. Setting higher timer frequency of 1000Hz would enable  us to achieve more responsive system better for desktops, while it will  be not efficient during large I/O operations because it will spend most  of the time dividing big I/O blocks into small pieces of time. We have  to remember that interrupt handler ,that in this case will be woken up  every 1ms, costs some CPU resources too. So there’s simple image –  higher frequency = lower latency + smaller throughput and on the other  hand we have opposite sittuation – lower frequency = less responsiveness  and larger throughput. There are times, however, when&nbsp; interrupt can be  unwelcome. Many processors, when idle, can go into a low-power state  until some work comes along. To such processors, the timer interrupt  looks like work.</blockquote><em> </em>Above concept is nicely illustrated on the picture 1.<br /><div class="wp-caption aligncenter" id="attachment_173" style="width: 310px;"><div class="separator" style="clear: both; text-align: center;"><a href="http://3.bp.blogspot.com/-6PRLvxP4Kqc/UbpBRFShNpI/AAAAAAAAAXc/ss8PEQOwD74/s1600/config_hz-im.jpg" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="173" src="http://3.bp.blogspot.com/-6PRLvxP4Kqc/UbpBRFShNpI/AAAAAAAAAXc/ss8PEQOwD74/s320/config_hz-im.jpg" width="320" /></a></div><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://2.bp.blogspot.com/-40pBOiPrdqY/UbpBZGC5nrI/AAAAAAAAAXk/BL4TeRKLZfY/s1600/2kb-test2.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="180" src="http://2.bp.blogspot.com/-40pBOiPrdqY/UbpBZGC5nrI/AAAAAAAAAXk/BL4TeRKLZfY/s320/2kb-test2.png" width="320" /></a></div><div class="separator" style="clear: both; text-align: center;">pic 2</div><div class="separator" style="clear: both; text-align: center;"><br /></div><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://2.bp.blogspot.com/-UVUwmGCLCVM/UbpBaX301eI/AAAAAAAAAXs/KWPEN-W0mp4/s1600/80kb-test.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="192" src="http://2.bp.blogspot.com/-UVUwmGCLCVM/UbpBaX301eI/AAAAAAAAAXs/KWPEN-W0mp4/s320/80kb-test.png" width="320" /></a></div><div class="separator" style="clear: both; text-align: center;">pic 3</div><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://2.bp.blogspot.com/-2TXT48w1bks/UbpBbCZTe7I/AAAAAAAAAX0/kNnus45ChZ0/s1600/10mb-test.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="192" src="http://2.bp.blogspot.com/-2TXT48w1bks/UbpBbCZTe7I/AAAAAAAAAX0/kNnus45ChZ0/s320/10mb-test.png" width="320" /></a></div><div class="separator" style="clear: both; text-align: center;">pic4</div><div class="wp-caption-text"><br /></div></div>Let’s see how will Timer Frequency setting affect <a href="http://www.cherokee-project.com/" target="_blank">Cherokee</a> server performance.<br />Below is our system configuration :<br /><ul><li> Debian stock kernel that comes with fresh installation “Linux  debian 2.6.32-5-686 #1 SMP Sat Jul 24 02:27:10 UTC 2010 i686 GNU/Linux”  on <a href="http://www.debian.org/releases/testing/" target="_blank">Debian Squeeze</a></li><li><a href="http://www.cherokee-project.com/" target="_blank">Cherokee www server </a>installed  from repositories via apt-get with no keepalives, no chunked encoding,  error-log and access-log disabled, with dynamic thread policy and  enabled I/O cache. Everything can be set easily through beautiful  cherokee-admin that comes with the server .</li></ul>Let’s do the simplest test simulating 1000 customers at a time that  want to do 10 static content requests each and repeat our test to  achieve the average result. Test are performed on 4 variants of kernel :<br /><ul><li>Stock kernel with no modifications ( NO_HZ )</li><li>Stock kernel with CONFIG_HZ=1000</li><li>Stock kernel with CONFIG_HZ=100</li><li>Custom minimalist kernel with NO_HZ – only needed drivers were left  inside the kernel and I tried to remove as many unneeded features as  possible</li></ul>I’ve prepared 3 test for each kernel – 2kb file (picture 2) ,80kb file (picture 3) and 10mb file (picture 4) .<br /><div class="wp-caption aligncenter" id="attachment_178" style="width: 310px;"><a href="http://www.314t.com/blog/wp-content/uploads/2010/09/2kb-test2.png"><img alt="" class="size-medium wp-image-178" height="169" src="http://www.314t.com/blog/wp-content/uploads/2010/09/2kb-test2-300x169.png" title="2kb test" width="300" /></a><br /><div class="wp-caption-text">Picture 2</div></div>- In diagram we can see that&nbsp; NO_HZ and Custom kernel win the competition (the more the better).<br /><div class="wp-caption aligncenter" id="attachment_180" style="width: 310px;"><a href="http://www.314t.com/blog/wp-content/uploads/2010/09/80kb-test.png"><img alt="" class="size-medium wp-image-180" height="180" src="http://www.314t.com/blog/wp-content/uploads/2010/09/80kb-test-300x180.png" title="80kb test" width="300" /></a><br /><div class="wp-caption-text">Picture 3</div></div>- Again on diagram 3 we have the same sittuation – the more the better.<br /><div class="wp-caption aligncenter" id="attachment_179" style="width: 310px;"><a href="http://www.314t.com/blog/wp-content/uploads/2010/09/10mb-test.png"><img alt="" class="size-medium wp-image-179" height="180" src="http://www.314t.com/blog/wp-content/uploads/2010/09/10mb-test-300x180.png" title="10mb test" width="300" /></a><br /><div class="wp-caption-text">Picture 4</div></div>- Last test is very interesting – it appears that Custom kernel with many optimizations won the competition.<br /><strong>Let’s summarize..</strong><br />During the tests I’ve found that optimizing the kernel for bigger throughput , we can <strong>gain up to 20% of performance</strong>. “Custom configuration” that won the competition was created with menuconfig following below steps :<br /><ol><li>Remove every unneeded&nbsp; kernel interface for external ,usually unused, application – for example Auditing Support (<a href="http://pl.wikipedia.org/wiki/Security-Enhanced_Linux" target="_blank">Selinux</a>) , Profiling support, Virtualization support</li><li>Optimizations for embedded systems (huh is bi-Xeon 32GB ram server embedded ? ) and security optimizations like “<a href="http://en.wikipedia.org/wiki/Address_space_layout_randomization" target="_blank">Heap randomization</a>“</li><li>Remove any no-latency and preemptive optimizations like High  Resolution Timer Support, HPET timer, SMT (hyperthreading) which is  really obsolete now</li><li>Choose “Server” Preemption mode as we don’t want system to have Desktop-style responsiveness</li><li>Remove any hardware unneeded features like old buses (ISA/PCI)</li><li>Remove any security options (do we really need any system security on our large farm member behind firewall ? )</li><li>Disabling any unneeded TCP/IP options like support for QoS etc. will also help – let the switches and routers do the job</li><li>Leave NO_HZ option so our system will decide how to dynamically assign Timer Frequency – it may also <strong>save up to 15% of electric power.</strong></li></ol>Do You remember 90′s when You recompiled old 2.2 and 2.4 kernels to  remove every unneeded module, and generally keep the kernel small ? <em>This approach is still alive!</em> As You can see we can gain so much computing power with the same hardware that <strong>server costs could be reduced almost by 20% </strong>and also <strong>monthly electric-energy costs can be reduced by 10% </strong>! We have to remember that stock kernels are build by system developers that take many <em>tradeoffs</em> to fulfill “good-for-all” concept.<br />But is “good-for-all” good for <strong>You</strong> ?</div></div>