---
layout: post
title: perf linux
date: '2014-07-03T22:37:00.001+05:00'
author: Abbas Raza
tags: 
modified_time: '2014-07-03T22:37:11.772+05:00'
blogger_id: tag:blogger.com,1999:blog-3367966882409306161.post-2713934571464711071
blogger_orig_url: https://abbas-raza.blogspot.com/2014/07/perf-linux.html
---

<div dir="ltr" style="text-align: left;" trbidi="on"><br /><h2><a class="anchor" href="https://gist.github.com/springmeyer/2945049#perf-guide" name="user-content-perf-guide" rel="noreferrer"></a>perf guide</h2>Profiling tools are critical for trying to understand performance bottlenecks in code.<br />  Without real data about what a program is doing while running,  detecting bottlenecks is at best a process of trial and error for both  users and developers. While thoughtful testing of various program  configurations along with measuring time elapsed for decrete runs can  often be enough - why not learn faster and funner ways to rapidly  collect real data about what a program is doing?<br />  Actual data about program execution like which functions are being  called while a program is active helps point to hot parts of the code  where most time may be being spent. While users of applications may not  easily understand the output of profiling tools, being equipped to  generate profiling output can be extremely useful for sharing with  developers, since the time to set up robust test cases for developers is  can be greater than the time it takes to understand and optimize slow  code paths. Therefore it can be invaluable to get a rough snapshot of  profiling output from users.<br />  This guide serves to instruct you, the user, to generate some useful  profiling output for the program you are running, to share with  developers.<br />  Many profiling tools exist on linux - others I've used with success include gprof and oprofile.<br />  But the two most valuable in my opinion are gdb and perf.<br />  <h2><a class="anchor" href="https://gist.github.com/springmeyer/2945049#perf" name="user-content-perf" rel="noreferrer"></a>Perf</h2><code>perf</code> is an amazing but relatively unknown profiling tool  built into the linux kernal. It is easy to install and run and can be  used either for quick analysis of what the whole system is doing (<code>perf top</code>) or advanced analysis and comparisions of multiple program benchmarking runs (<code>perf record</code>).<br />  It does not require recompiling your c-land programs, so it can be  easily used in production systems to debug slow running code or to  understand where bottlenecks are. If your program is compiled in debug  mode <code>perf</code> is able to provide more detailed call graphs and annotation of code hot spots.<br />  <h3><a class="anchor" href="https://gist.github.com/springmeyer/2945049#installing-perf" name="user-content-installing-perf" rel="noreferrer"></a>Installing Perf</h3>Install <code>linux-tools-common</code> first:<br />  <pre><code>sudo apt-get update<br />sudo apt-get install linux-tools-common<br />sudo apt-get install linux-base<br />uname_r=$(uname -r)<br />sudo apt-get install linux-tools-${u%-virtual}<br /></code></pre>You should now have the <code>perf</code> command. Run it as root like:<br />  <pre><code>sudo perf --help<br /></code></pre><h3><a class="anchor" href="https://gist.github.com/springmeyer/2945049#perf-top" name="user-content-perf-top" rel="noreferrer"></a>Perf top</h3>Running <code>perf top</code> will provide a real-time aggregate of functions where most of the time is spent across all cpu's and processes.<br />  <pre><code>sudo perf top<br /></code></pre><h3><a class="anchor" href="https://gist.github.com/springmeyer/2945049#perf-record" name="user-content-perf-record" rel="noreferrer"></a>Perf record</h3>To isolate profiling to a single process or program use <code>perf record</code>. You can launch a process under <code>perf record</code> or attach to an already running process<br />  Run a program with <code>perf record</code> and profile until the program exits:<br />  <pre><code>sudo perf record ./test-program<br /></code></pre>Attach to a running program:<br />  <pre><code>sudo perf record --pid `pidof program-name` # ctrl-c to stop recording<br /></code></pre>Handy options to perf record are:<br />  <ul class="task-list"><li><code>-a</code>: force <code>perf record</code> to track all cpus</li><li><code>-g</code>: generates call graph information</li></ul>NOTE: more recent <code>perf</code> versions may require an argument tobe passed after the <code>-g</code> like <code>dwarf</code><br />  <h3><a class="anchor" href="https://gist.github.com/springmeyer/2945049#perf-report" name="user-content-perf-report" rel="noreferrer"></a>Perf report</h3>To view the profiling results you use <code>perf report</code>.<br />  To bring up an interactive console interface with details do:<br />  <pre><code>sudo perf report<br /></code></pre>To dump out all the details of the report to a shareable text file do:<br />  <pre><code>sudo perf report &gt; profiling-results.txt<br /></code></pre><h3><a class="anchor" href="https://gist.github.com/springmeyer/2945049#perf-additional-docs" name="user-content-perf-additional-docs" rel="noreferrer"></a>Perf additional docs</h3><ul class="task-list"><li>The developers notes: <a href="http://lxr.free-electrons.com/source/tools/perf/Documentation/examples.txt" rel="noreferrer">http://lxr.free-electrons.com/source/tools/perf/Documentation/examples.txt</a></li><li>Compared to oprofile/gprof: <a href="http://rhaas.blogspot.com/2012/06/perf-good-bad-ugly.html" rel="noreferrer">http://rhaas.blogspot.com/2012/06/perf-good-bad-ugly.html</a></li><li>Detailed wiki with tutorial: <a href="https://perf.wiki.kernel.org/index.php/Main_Page" rel="noreferrer">https://perf.wiki.kernel.org/index.php/Main_Page</a></li></ul><h3><a class="anchor" href="https://gist.github.com/springmeyer/2945049#advanced-uses-of-perf" name="user-content-advanced-uses-of-perf" rel="noreferrer"></a>Advanced uses of Perf</h3><ul class="task-list"><li>Undertanding memory access: <a href="http://mechanical-sympathy.blogspot.co.uk/2012/08/memory-access-patterns-are-important.html" rel="noreferrer">http://mechanical-sympathy.blogspot.co.uk/2012/08/memory-access-patterns-are-important.html</a></li></ul></div>